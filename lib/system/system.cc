
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <sys/times.h>

#include <sys/resource.h>

#include <unistd.h>

#include <sys/wait.h>

#include <signal.h>

#include <sys/mman.h>


#ifdef __linux__
#include <sys/eventfd.h>
#include <sys/timerfd.h>
#include <sys/sysinfo.h>
#include <linux/userfaultfd.h>
#endif



#include <lo.h>

namespace lo {
namespace system {

using v8::FunctionCallbackInfo;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Integer;
using v8::Number;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::CFunction;
using v8::CTypeInfo;
using v8::Uint8Array;
using v8::CFunctionInfo;
using v8::String;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Function;
using v8::Object;
using v8::HandleScope;
using v8::BigInt;


#ifdef __linux__

#ifdef __cplusplus
extern "C"
    {
#endif
    extern
    int __xpg_strerror_r(int errcode,char* buffer,size_t length);
    #define strerror_r __xpg_strerror_r
#ifdef __cplusplus
    }
#endif

#endif
#ifdef __MACH__

#endif

void mmapFast(void* p, uint64_t* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, uint64_t* p_ret);
CTypeInfo cargsmmap[8] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmmap = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infommap = CFunctionInfo(rcmmap, 8, cargsmmap);
CFunction pFmmap = CFunction((const void*)&mmapFast, &infommap);

int32_t munmapFast(void* p, uint64_t* p0, uint32_t p1);
CTypeInfo cargsmunmap[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcmunmap = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomunmap = CFunctionInfo(rcmunmap, 3, cargsmunmap);
CFunction pFmunmap = CFunction((const void*)&munmapFast, &infomunmap);

void getcwdFast(void* p, uint64_t* p0, int32_t p1, uint64_t* p_ret);
CTypeInfo cargsgetcwd[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcgetcwd = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infogetcwd = CFunctionInfo(rcgetcwd, 4, cargsgetcwd);
CFunction pFgetcwd = CFunction((const void*)&getcwdFast, &infogetcwd);

int32_t mprotectFast(void* p, uint64_t* p0, uint32_t p1, int32_t p2);
CTypeInfo cargsmprotect[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcmprotect = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomprotect = CFunctionInfo(rcmprotect, 4, cargsmprotect);
CFunction pFmprotect = CFunction((const void*)&mprotectFast, &infomprotect);

void memcpyFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret);
CTypeInfo cargsmemcpy[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmemcpy = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemcpy = CFunctionInfo(rcmemcpy, 5, cargsmemcpy);
CFunction pFmemcpy = CFunction((const void*)&memcpyFast, &infomemcpy);

void memmoveFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret);
CTypeInfo cargsmemmove[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmemmove = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemmove = CFunctionInfo(rcmemmove, 5, cargsmemmove);
CFunction pFmemmove = CFunction((const void*)&memmoveFast, &infomemmove);

void exitFast(void* p, int32_t p0);
CTypeInfo cargsexit[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcexit = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoexit = CFunctionInfo(rcexit, 2, cargsexit);
CFunction pFexit = CFunction((const void*)&exitFast, &infoexit);

int32_t usleepFast(void* p, uint32_t p0);
CTypeInfo cargsusleep[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcusleep = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infousleep = CFunctionInfo(rcusleep, 2, cargsusleep);
CFunction pFusleep = CFunction((const void*)&usleepFast, &infousleep);

int32_t getpidFast(void* p);
CTypeInfo cargsgetpid[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcgetpid = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetpid = CFunctionInfo(rcgetpid, 1, cargsgetpid);
CFunction pFgetpid = CFunction((const void*)&getpidFast, &infogetpid);

int32_t getrusageFast(void* p, int32_t p0, uint64_t* p1);
CTypeInfo cargsgetrusage[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcgetrusage = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetrusage = CFunctionInfo(rcgetrusage, 3, cargsgetrusage);
CFunction pFgetrusage = CFunction((const void*)&getrusageFast, &infogetrusage);

uint32_t sleepFast(void* p, uint32_t p0);
CTypeInfo cargssleep[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcsleep = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infosleep = CFunctionInfo(rcsleep, 2, cargssleep);
CFunction pFsleep = CFunction((const void*)&sleepFast, &infosleep);

int32_t forkFast(void* p);
CTypeInfo cargsfork[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcfork = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofork = CFunctionInfo(rcfork, 1, cargsfork);
CFunction pFfork = CFunction((const void*)&forkFast, &infofork);

int32_t killFast(void* p, int32_t p0, int32_t p1);
CTypeInfo cargskill[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rckill = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infokill = CFunctionInfo(rckill, 3, cargskill);
CFunction pFkill = CFunction((const void*)&killFast, &infokill);

int32_t waitpidFast(void* p, int32_t p0, uint64_t* p1, int32_t p2);
CTypeInfo cargswaitpid[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcwaitpid = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowaitpid = CFunctionInfo(rcwaitpid, 4, cargswaitpid);
CFunction pFwaitpid = CFunction((const void*)&waitpidFast, &infowaitpid);

int32_t execvpFast(void* p, struct FastOneByteString* const p0, uint64_t* p1);
CTypeInfo cargsexecvp[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcexecvp = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoexecvp = CFunctionInfo(rcexecvp, 3, cargsexecvp);
CFunction pFexecvp = CFunction((const void*)&execvpFast, &infoexecvp);

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, uint64_t* p1, uint32_t p2);
CTypeInfo cargsreadlink[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcreadlink = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo inforeadlink = CFunctionInfo(rcreadlink, 4, cargsreadlink);
CFunction pFreadlink = CFunction((const void*)&readlinkFast, &inforeadlink);

uint32_t sysconfFast(void* p, int32_t p0);
CTypeInfo cargssysconf[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcsysconf = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infosysconf = CFunctionInfo(rcsysconf, 2, cargssysconf);
CFunction pFsysconf = CFunction((const void*)&sysconfFast, &infosysconf);

int32_t getrlimitFast(void* p, int32_t p0, uint64_t* p1);
CTypeInfo cargsgetrlimit[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcgetrlimit = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetrlimit = CFunctionInfo(rcgetrlimit, 3, cargsgetrlimit);
CFunction pFgetrlimit = CFunction((const void*)&getrlimitFast, &infogetrlimit);

int32_t setrlimitFast(void* p, int32_t p0, uint64_t* p1);
CTypeInfo cargssetrlimit[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcsetrlimit = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infosetrlimit = CFunctionInfo(rcsetrlimit, 3, cargssetrlimit);
CFunction pFsetrlimit = CFunction((const void*)&setrlimitFast, &infosetrlimit);

int32_t strerror_rFast(void* p, int32_t p0, uint64_t* p1, uint32_t p2);
CTypeInfo cargsstrerror_r[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcstrerror_r = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infostrerror_r = CFunctionInfo(rcstrerror_r, 4, cargsstrerror_r);
CFunction pFstrerror_r = CFunction((const void*)&strerror_rFast, &infostrerror_r);

int32_t timesFast(void* p, uint64_t* p0);
CTypeInfo cargstimes[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rctimes = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infotimes = CFunctionInfo(rctimes, 2, cargstimes);
CFunction pFtimes = CFunction((const void*)&timesFast, &infotimes);

void getenvFast(void* p, struct FastOneByteString* const p0, uint64_t* p_ret);
CTypeInfo cargsgetenv[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcgetenv = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infogetenv = CFunctionInfo(rcgetenv, 3, cargsgetenv);
CFunction pFgetenv = CFunction((const void*)&getenvFast, &infogetenv);

void callocFast(void* p, uint32_t p0, uint32_t p1, uint64_t* p_ret);
CTypeInfo cargscalloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rccalloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infocalloc = CFunctionInfo(rccalloc, 4, cargscalloc);
CFunction pFcalloc = CFunction((const void*)&callocFast, &infocalloc);

void freeFast(void* p, uint64_t* p0);
CTypeInfo cargsfree[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcfree = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infofree = CFunctionInfo(rcfree, 2, cargsfree);
CFunction pFfree = CFunction((const void*)&freeFast, &infofree);

#ifdef __linux__

uint32_t sysinfoFast(void* p, uint64_t* p0);
CTypeInfo cargssysinfo[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcsysinfo = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infosysinfo = CFunctionInfo(rcsysinfo, 2, cargssysinfo);
CFunction pFsysinfo = CFunction((const void*)&sysinfoFast, &infosysinfo);

uint32_t get_avphys_pagesFast(void* p);
CTypeInfo cargsget_avphys_pages[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcget_avphys_pages = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infoget_avphys_pages = CFunctionInfo(rcget_avphys_pages, 1, cargsget_avphys_pages);
CFunction pFget_avphys_pages = CFunction((const void*)&get_avphys_pagesFast, &infoget_avphys_pages);

void signalFast(void* p, int32_t p0, uint64_t* p1, uint64_t* p_ret);
CTypeInfo cargssignal[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcsignal = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infosignal = CFunctionInfo(rcsignal, 4, cargssignal);
CFunction pFsignal = CFunction((const void*)&signalFast, &infosignal);

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1);
CTypeInfo cargsmemfd_create[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcmemfd_create = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomemfd_create = CFunctionInfo(rcmemfd_create, 3, cargsmemfd_create);
CFunction pFmemfd_create = CFunction((const void*)&memfd_createFast, &infomemfd_create);

int32_t pidfd_openFast(void* p, int32_t p0, int32_t p1, uint32_t p2);
CTypeInfo cargspidfd_open[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcpidfd_open = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infopidfd_open = CFunctionInfo(rcpidfd_open, 4, cargspidfd_open);
CFunction pFpidfd_open = CFunction((const void*)&pidfd_openFast, &infopidfd_open);

int32_t gettidFast(void* p, int32_t p0);
CTypeInfo cargsgettid[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcgettid = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogettid = CFunctionInfo(rcgettid, 2, cargsgettid);
CFunction pFgettid = CFunction((const void*)&gettidFast, &infogettid);

int32_t timerfd_createFast(void* p, int32_t p0, int32_t p1);
CTypeInfo cargstimerfd_create[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rctimerfd_create = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infotimerfd_create = CFunctionInfo(rctimerfd_create, 3, cargstimerfd_create);
CFunction pFtimerfd_create = CFunction((const void*)&timerfd_createFast, &infotimerfd_create);

int32_t timerfd_settimeFast(void* p, int32_t p0, int32_t p1, uint64_t* p2, uint64_t* p3);
CTypeInfo cargstimerfd_settime[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rctimerfd_settime = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infotimerfd_settime = CFunctionInfo(rctimerfd_settime, 5, cargstimerfd_settime);
CFunction pFtimerfd_settime = CFunction((const void*)&timerfd_settimeFast, &infotimerfd_settime);

int32_t eventfdFast(void* p, uint32_t p0, int32_t p1);
CTypeInfo cargseventfd[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rceventfd = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoeventfd = CFunctionInfo(rceventfd, 3, cargseventfd);
CFunction pFeventfd = CFunction((const void*)&eventfdFast, &infoeventfd);

int32_t clock_gettimeFast(void* p, int32_t p0, uint64_t* p1);
CTypeInfo cargsclock_gettime[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcclock_gettime = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoclock_gettime = CFunctionInfo(rcclock_gettime, 3, cargsclock_gettime);
CFunction pFclock_gettime = CFunction((const void*)&clock_gettimeFast, &infoclock_gettime);

#endif
#ifdef __MACH__

#endif

void mmapSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t v4 = Local<Integer>::Cast(args[4])->Value();
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  void* rc = mmap(v0, v1, v2, v3, v4, v5);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void mmapFast(void* p, uint64_t* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  int32_t v3 = p3;
  int32_t v4 = p4;
  uint32_t v5 = p5;
  void* r = mmap(v0, v1, v2, v3, v4, v5);

  p_ret[0] = (uint64_t)r;
}
void munmapSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = munmap(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t munmapFast(void* p, uint64_t* p0, uint32_t p1) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  return munmap(v0, v1);
}
void getcwdSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  char* rc = getcwd(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void getcwdFast(void* p, uint64_t* p0, int32_t p1, uint64_t* p_ret) {
  char* v0 = reinterpret_cast<char*>(p0);
  int32_t v1 = p1;
  char* r = getcwd(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void mprotectSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = mprotect(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t mprotectFast(void* p, uint64_t* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return mprotect(v0, v1, v2);
}
void memcpySlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memcpy(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void memcpyFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memcpy(v0, v1, v2);

  p_ret[0] = (uint64_t)r;
}
void memmoveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memmove(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void memmoveFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memmove(v0, v1, v2);

  p_ret[0] = (uint64_t)r;
}
void exitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  exit(v0);
}

void exitFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  exit(v0);
}
void usleepSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = usleep(v0);
  args.GetReturnValue().Set(rc);
}

int32_t usleepFast(void* p, uint32_t p0) {
  uint32_t v0 = p0;
  return usleep(v0);
}
void getpidSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getpid();
  args.GetReturnValue().Set(rc);
}

int32_t getpidFast(void* p) {

  return getpid();
}
void getrusageSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  struct rusage* v1 = reinterpret_cast<struct rusage*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = getrusage(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t getrusageFast(void* p, int32_t p0, uint64_t* p1) {
  int32_t v0 = p0;
  struct rusage* v1 = reinterpret_cast<struct rusage*>(p1);
  return getrusage(v0, v1);
}
void sleepSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t rc = sleep(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t sleepFast(void* p, uint32_t p0) {
  uint32_t v0 = p0;
  return sleep(v0);
}
void forkSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = fork();
  args.GetReturnValue().Set(rc);
}

int32_t forkFast(void* p) {

  return fork();
}
void killSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = kill(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t killFast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return kill(v0, v1);
}
void waitpidSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int* v1 = reinterpret_cast<int*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = waitpid(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t waitpidFast(void* p, int32_t p0, uint64_t* p1, int32_t p2) {
  int32_t v0 = p0;
  int* v1 = reinterpret_cast<int*>(p1);
  int32_t v2 = p2;
  return waitpid(v0, v1, v2);
}
void execvpSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* const* v1 = reinterpret_cast<char* const*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = execvp(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t execvpFast(void* p, struct FastOneByteString* const p0, uint64_t* p1) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1);
  return execvp(v0->data, v1);
}
void readlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* v1 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = readlink(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, uint64_t* p1, uint32_t p2) {
  struct FastOneByteString* const v0 = p0;
  char* v1 = reinterpret_cast<char*>(p1);
  uint32_t v2 = p2;
  return readlink(v0->data, v1, v2);
}
void sysconfSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t rc = sysconf(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t sysconfFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return sysconf(v0);
}
void getrlimitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  struct rlimit* v1 = reinterpret_cast<struct rlimit*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = getrlimit(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t getrlimitFast(void* p, int32_t p0, uint64_t* p1) {
  int32_t v0 = p0;
  struct rlimit* v1 = reinterpret_cast<struct rlimit*>(p1);
  return getrlimit(v0, v1);
}
void setrlimitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  const struct rlimit* v1 = reinterpret_cast<const struct rlimit*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = setrlimit(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t setrlimitFast(void* p, int32_t p0, uint64_t* p1) {
  int32_t v0 = p0;
  const struct rlimit* v1 = reinterpret_cast<const struct rlimit*>(p1);
  return setrlimit(v0, v1);
}
void strerror_rSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  char* v1 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = strerror_r(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t strerror_rFast(void* p, int32_t p0, uint64_t* p1, uint32_t p2) {
  int32_t v0 = p0;
  char* v1 = reinterpret_cast<char*>(p1);
  uint32_t v2 = p2;
  return strerror_r(v0, v1, v2);
}
void timesSlow(const FunctionCallbackInfo<Value> &args) {
  struct tms* v0 = reinterpret_cast<struct tms*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = times(v0);
  args.GetReturnValue().Set(rc);
}

int32_t timesFast(void* p, uint64_t* p0) {
  struct tms* v0 = reinterpret_cast<struct tms*>(p0);
  return times(v0);
}
void getenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* rc = getenv(*v0);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void getenvFast(void* p, struct FastOneByteString* const p0, uint64_t* p_ret) {
  struct FastOneByteString* const v0 = p0;
  char* r = getenv(v0->data);

  p_ret[0] = (uint64_t)r;
}
void callocSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = calloc(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void callocFast(void* p, uint32_t p0, uint32_t p1, uint64_t* p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = calloc(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  free(v0);
}

void freeFast(void* p, uint64_t* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  free(v0);
}
#ifdef __linux__

void sysinfoSlow(const FunctionCallbackInfo<Value> &args) {
  struct sysinfo* v0 = reinterpret_cast<struct sysinfo*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t rc = sysinfo(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t sysinfoFast(void* p, uint64_t* p0) {
  struct sysinfo* v0 = reinterpret_cast<struct sysinfo*>(p0);
  return sysinfo(v0);
}
void get_avphys_pagesSlow(const FunctionCallbackInfo<Value> &args) {

  uint32_t rc = get_avphys_pages();
  args.GetReturnValue().Set(rc);
}

uint32_t get_avphys_pagesFast(void* p) {

  return get_avphys_pages();
}
void signalSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  sighandler_t v1 = reinterpret_cast<sighandler_t>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  sighandler_t rc = signal(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void signalFast(void* p, int32_t p0, uint64_t* p1, uint64_t* p_ret) {
  int32_t v0 = p0;
  sighandler_t v1 = reinterpret_cast<sighandler_t>(p1);
  sighandler_t r = signal(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void memfd_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = memfd_create(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p1;
  return memfd_create(v0->data, v1);
}
void pidfd_openSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = syscall(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t pidfd_openFast(void* p, int32_t p0, int32_t p1, uint32_t p2) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  uint32_t v2 = p2;
  return syscall(v0, v1, v2);
}
void gettidSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = syscall(v0);
  args.GetReturnValue().Set(rc);
}

int32_t gettidFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return syscall(v0);
}
void timerfd_createSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = timerfd_create(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t timerfd_createFast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return timerfd_create(v0, v1);
}
void timerfd_settimeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  const struct itimerspec* v2 = reinterpret_cast<const struct itimerspec*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  struct itimerspec* v3 = reinterpret_cast<struct itimerspec*>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  int32_t rc = timerfd_settime(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t timerfd_settimeFast(void* p, int32_t p0, int32_t p1, uint64_t* p2, uint64_t* p3) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  const struct itimerspec* v2 = reinterpret_cast<const struct itimerspec*>(p2);
  struct itimerspec* v3 = reinterpret_cast<struct itimerspec*>(p3);
  return timerfd_settime(v0, v1, v2, v3);
}
void eventfdSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = eventfd(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t eventfdFast(void* p, uint32_t p0, int32_t p1) {
  uint32_t v0 = p0;
  int32_t v1 = p1;
  return eventfd(v0, v1);
}
void clock_gettimeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  timespec* v1 = reinterpret_cast<timespec*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = clock_gettime(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t clock_gettimeFast(void* p, int32_t p0, uint64_t* p1) {
  int32_t v0 = p0;
  timespec* v1 = reinterpret_cast<timespec*>(p1);
  return clock_gettime(v0, v1);
}
#endif
#ifdef __MACH__

#endif
void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "mmap", &pFmmap, mmapSlow);
  SET_FAST_METHOD(isolate, module, "munmap", &pFmunmap, munmapSlow);
  SET_FAST_METHOD(isolate, module, "getcwd", &pFgetcwd, getcwdSlow);
  SET_FAST_METHOD(isolate, module, "mprotect", &pFmprotect, mprotectSlow);
  SET_FAST_METHOD(isolate, module, "memcpy", &pFmemcpy, memcpySlow);
  SET_FAST_METHOD(isolate, module, "memmove", &pFmemmove, memmoveSlow);
  SET_FAST_METHOD(isolate, module, "exit", &pFexit, exitSlow);
  SET_FAST_METHOD(isolate, module, "usleep", &pFusleep, usleepSlow);
  SET_FAST_METHOD(isolate, module, "getpid", &pFgetpid, getpidSlow);
  SET_FAST_METHOD(isolate, module, "getrusage", &pFgetrusage, getrusageSlow);
  SET_FAST_METHOD(isolate, module, "sleep", &pFsleep, sleepSlow);
  SET_FAST_METHOD(isolate, module, "fork", &pFfork, forkSlow);
  SET_FAST_METHOD(isolate, module, "kill", &pFkill, killSlow);
  SET_FAST_METHOD(isolate, module, "waitpid", &pFwaitpid, waitpidSlow);
  SET_FAST_METHOD(isolate, module, "execvp", &pFexecvp, execvpSlow);
  SET_FAST_METHOD(isolate, module, "readlink", &pFreadlink, readlinkSlow);
  SET_FAST_METHOD(isolate, module, "sysconf", &pFsysconf, sysconfSlow);
  SET_FAST_METHOD(isolate, module, "getrlimit", &pFgetrlimit, getrlimitSlow);
  SET_FAST_METHOD(isolate, module, "setrlimit", &pFsetrlimit, setrlimitSlow);
  SET_FAST_METHOD(isolate, module, "strerror_r", &pFstrerror_r, strerror_rSlow);
  SET_FAST_METHOD(isolate, module, "times", &pFtimes, timesSlow);
  SET_FAST_METHOD(isolate, module, "getenv", &pFgetenv, getenvSlow);
  SET_FAST_METHOD(isolate, module, "calloc", &pFcalloc, callocSlow);
  SET_FAST_METHOD(isolate, module, "free", &pFfree, freeSlow);

#ifdef __linux__
  SET_FAST_METHOD(isolate, module, "sysinfo", &pFsysinfo, sysinfoSlow);
  SET_FAST_METHOD(isolate, module, "get_avphys_pages", &pFget_avphys_pages, get_avphys_pagesSlow);
  SET_FAST_METHOD(isolate, module, "signal", &pFsignal, signalSlow);
  SET_FAST_METHOD(isolate, module, "memfd_create", &pFmemfd_create, memfd_createSlow);
  SET_FAST_METHOD(isolate, module, "pidfd_open", &pFpidfd_open, pidfd_openSlow);
  SET_FAST_METHOD(isolate, module, "gettid", &pFgettid, gettidSlow);
  SET_FAST_METHOD(isolate, module, "timerfd_create", &pFtimerfd_create, timerfd_createSlow);
  SET_FAST_METHOD(isolate, module, "timerfd_settime", &pFtimerfd_settime, timerfd_settimeSlow);
  SET_FAST_METHOD(isolate, module, "eventfd", &pFeventfd, eventfdSlow);
  SET_FAST_METHOD(isolate, module, "clock_gettime", &pFclock_gettime, clock_gettimeSlow);

#endif
#ifdef __MACH__

#endif
  SET_VALUE(isolate, module, "_SC_CLK_TCK", Integer::New(isolate, (int32_t)_SC_CLK_TCK));
  SET_VALUE(isolate, module, "_SC_NPROCESSORS_ONLN", Integer::New(isolate, (int32_t)_SC_NPROCESSORS_ONLN));
  SET_VALUE(isolate, module, "CLOCK_MONOTONIC", Integer::New(isolate, (int32_t)CLOCK_MONOTONIC));
  SET_VALUE(isolate, module, "CLOCK_MONOTONIC_RAW", Integer::New(isolate, (int32_t)CLOCK_MONOTONIC_RAW));
  SET_VALUE(isolate, module, "CLOCK_REALTIME", Integer::New(isolate, (int32_t)CLOCK_REALTIME));

#ifdef __linux__
  SET_VALUE(isolate, module, "EFD_NONBLOCK", Integer::New(isolate, (int32_t)EFD_NONBLOCK));
  SET_VALUE(isolate, module, "EFD_CLOEXEC", Integer::New(isolate, (int32_t)EFD_CLOEXEC));
  SET_VALUE(isolate, module, "EFD_SEMAPHORE", Integer::New(isolate, (int32_t)EFD_SEMAPHORE));
  SET_VALUE(isolate, module, "CLOCK_MONOTONIC_COARSE", Integer::New(isolate, (int32_t)CLOCK_MONOTONIC_COARSE));
  SET_VALUE(isolate, module, "CLOCK_BOOTTIME", Integer::New(isolate, (int32_t)CLOCK_BOOTTIME));

#endif
#ifdef __MACH__

#endif

#ifdef __MACH__

#endif
#ifdef __linux__

#endif
  SET_MODULE(isolate, target, "system", module);
}
} // namespace system
} // namespace lo

extern "C"  {
  DLL_PUBLIC void* _register_system() {
    return (void*)lo::system::Init;
  }
}
