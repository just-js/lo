
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <sys/times.h>
#include <sys/resource.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/eventfd.h>
#include <sys/timerfd.h>
#include <sys/sysinfo.h>
#include <linux/userfaultfd.h>
#include <lo.h>

namespace lo {
namespace system {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;
using v8::BigInt;


#ifdef __cplusplus
extern "C"
    {
#endif
    extern 
    int __xpg_strerror_r(int errcode,char* buffer,size_t length);
    #define strerror_r __xpg_strerror_r

#ifdef __cplusplus
    }
#endif


void mmapFast(void* p, void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmmap[8] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmmap = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infommap = v8::CFunctionInfo(rcmmap, 8, cargsmmap);
v8::CFunction pFmmap = v8::CFunction((const void*)&mmapFast, &infommap);

int32_t munmapFast(void* p, void* p0, uint32_t p1);
v8::CTypeInfo cargsmunmap[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcmunmap = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomunmap = v8::CFunctionInfo(rcmunmap, 3, cargsmunmap);
v8::CFunction pFmunmap = v8::CFunction((const void*)&munmapFast, &infomunmap);

void getcwdFast(void* p, struct FastApiTypedArray* const p0, int32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsgetcwd[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcgetcwd = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogetcwd = v8::CFunctionInfo(rcgetcwd, 4, cargsgetcwd);
v8::CFunction pFgetcwd = v8::CFunction((const void*)&getcwdFast, &infogetcwd);

int32_t eventfdFast(void* p, uint32_t p0, int32_t p1);
v8::CTypeInfo cargseventfd[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rceventfd = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoeventfd = v8::CFunctionInfo(rceventfd, 3, cargseventfd);
v8::CFunction pFeventfd = v8::CFunction((const void*)&eventfdFast, &infoeventfd);

int32_t clock_gettimeFast(void* p, int32_t p0, void* p1);
v8::CTypeInfo cargsclock_gettime[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcclock_gettime = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoclock_gettime = v8::CFunctionInfo(rcclock_gettime, 3, cargsclock_gettime);
v8::CFunction pFclock_gettime = v8::CFunction((const void*)&clock_gettimeFast, &infoclock_gettime);

int32_t mprotectFast(void* p, void* p0, uint32_t p1, int32_t p2);
v8::CTypeInfo cargsmprotect[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcmprotect = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomprotect = v8::CFunctionInfo(rcmprotect, 4, cargsmprotect);
v8::CFunction pFmprotect = v8::CFunction((const void*)&mprotectFast, &infomprotect);

void memcpyFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmemcpy[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmemcpy = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomemcpy = v8::CFunctionInfo(rcmemcpy, 5, cargsmemcpy);
v8::CFunction pFmemcpy = v8::CFunction((const void*)&memcpyFast, &infomemcpy);

void memmoveFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmemmove[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmemmove = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomemmove = v8::CFunctionInfo(rcmemmove, 5, cargsmemmove);
v8::CFunction pFmemmove = v8::CFunction((const void*)&memmoveFast, &infomemmove);

void exitFast(void* p, int32_t p0);
v8::CTypeInfo cargsexit[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcexit = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infoexit = v8::CFunctionInfo(rcexit, 2, cargsexit);
v8::CFunction pFexit = v8::CFunction((const void*)&exitFast, &infoexit);

int32_t usleepFast(void* p, uint32_t p0);
v8::CTypeInfo cargsusleep[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcusleep = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infousleep = v8::CFunctionInfo(rcusleep, 2, cargsusleep);
v8::CFunction pFusleep = v8::CFunction((const void*)&usleepFast, &infousleep);

int32_t getpidFast(void* p);
v8::CTypeInfo cargsgetpid[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcgetpid = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetpid = v8::CFunctionInfo(rcgetpid, 1, cargsgetpid);
v8::CFunction pFgetpid = v8::CFunction((const void*)&getpidFast, &infogetpid);

int32_t getrusageFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsgetrusage[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcgetrusage = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetrusage = v8::CFunctionInfo(rcgetrusage, 3, cargsgetrusage);
v8::CFunction pFgetrusage = v8::CFunction((const void*)&getrusageFast, &infogetrusage);

int32_t timerfd_createFast(void* p, int32_t p0, int32_t p1);
v8::CTypeInfo cargstimerfd_create[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rctimerfd_create = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infotimerfd_create = v8::CFunctionInfo(rctimerfd_create, 3, cargstimerfd_create);
v8::CFunction pFtimerfd_create = v8::CFunction((const void*)&timerfd_createFast, &infotimerfd_create);

uint32_t sleepFast(void* p, uint32_t p0);
v8::CTypeInfo cargssleep[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcsleep = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infosleep = v8::CFunctionInfo(rcsleep, 2, cargssleep);
v8::CFunction pFsleep = v8::CFunction((const void*)&sleepFast, &infosleep);

int32_t timerfd_settimeFast(void* p, int32_t p0, int32_t p1, struct FastApiTypedArray* const p2, void* p3);
v8::CTypeInfo cargstimerfd_settime[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rctimerfd_settime = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infotimerfd_settime = v8::CFunctionInfo(rctimerfd_settime, 5, cargstimerfd_settime);
v8::CFunction pFtimerfd_settime = v8::CFunction((const void*)&timerfd_settimeFast, &infotimerfd_settime);

int32_t forkFast(void* p);
v8::CTypeInfo cargsfork[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcfork = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infofork = v8::CFunctionInfo(rcfork, 1, cargsfork);
v8::CFunction pFfork = v8::CFunction((const void*)&forkFast, &infofork);

int32_t killFast(void* p, int32_t p0, int32_t p1);
v8::CTypeInfo cargskill[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rckill = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infokill = v8::CFunctionInfo(rckill, 3, cargskill);
v8::CFunction pFkill = v8::CFunction((const void*)&killFast, &infokill);

int32_t waitpidFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
v8::CTypeInfo cargswaitpid[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcwaitpid = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infowaitpid = v8::CFunctionInfo(rcwaitpid, 4, cargswaitpid);
v8::CFunction pFwaitpid = v8::CFunction((const void*)&waitpidFast, &infowaitpid);

int32_t execvpFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsexecvp[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcexecvp = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoexecvp = v8::CFunctionInfo(rcexecvp, 3, cargsexecvp);
v8::CFunction pFexecvp = v8::CFunction((const void*)&execvpFast, &infoexecvp);

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, uint32_t p2);
v8::CTypeInfo cargsreadlink[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcreadlink = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo inforeadlink = v8::CFunctionInfo(rcreadlink, 4, cargsreadlink);
v8::CFunction pFreadlink = v8::CFunction((const void*)&readlinkFast, &inforeadlink);

uint32_t sysconfFast(void* p, int32_t p0);
v8::CTypeInfo cargssysconf[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcsysconf = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infosysconf = v8::CFunctionInfo(rcsysconf, 2, cargssysconf);
v8::CFunction pFsysconf = v8::CFunction((const void*)&sysconfFast, &infosysconf);

int32_t pidfd_openFast(void* p, int32_t p0, int32_t p1, uint32_t p2);
v8::CTypeInfo cargspidfd_open[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcpidfd_open = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infopidfd_open = v8::CFunctionInfo(rcpidfd_open, 4, cargspidfd_open);
v8::CFunction pFpidfd_open = v8::CFunction((const void*)&pidfd_openFast, &infopidfd_open);

int32_t gettidFast(void* p, int32_t p0);
v8::CTypeInfo cargsgettid[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcgettid = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogettid = v8::CFunctionInfo(rcgettid, 2, cargsgettid);
v8::CFunction pFgettid = v8::CFunction((const void*)&gettidFast, &infogettid);

int32_t getrlimitFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsgetrlimit[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcgetrlimit = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetrlimit = v8::CFunctionInfo(rcgetrlimit, 3, cargsgetrlimit);
v8::CFunction pFgetrlimit = v8::CFunction((const void*)&getrlimitFast, &infogetrlimit);

int32_t setrlimitFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargssetrlimit[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcsetrlimit = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infosetrlimit = v8::CFunctionInfo(rcsetrlimit, 3, cargssetrlimit);
v8::CFunction pFsetrlimit = v8::CFunction((const void*)&setrlimitFast, &infosetrlimit);

int32_t strerror_rFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, uint32_t p2);
v8::CTypeInfo cargsstrerror_r[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcstrerror_r = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infostrerror_r = v8::CFunctionInfo(rcstrerror_r, 4, cargsstrerror_r);
v8::CFunction pFstrerror_r = v8::CFunction((const void*)&strerror_rFast, &infostrerror_r);

int32_t timesFast(void* p, struct FastApiTypedArray* const p0);
v8::CTypeInfo cargstimes[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rctimes = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infotimes = v8::CFunctionInfo(rctimes, 2, cargstimes);
v8::CFunction pFtimes = v8::CFunction((const void*)&timesFast, &infotimes);

uint32_t sysinfoFast(void* p, struct FastApiTypedArray* const p0);
v8::CTypeInfo cargssysinfo[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcsysinfo = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infosysinfo = v8::CFunctionInfo(rcsysinfo, 2, cargssysinfo);
v8::CFunction pFsysinfo = v8::CFunction((const void*)&sysinfoFast, &infosysinfo);

uint32_t get_avphys_pagesFast(void* p);
v8::CTypeInfo cargsget_avphys_pages[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcget_avphys_pages = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infoget_avphys_pages = v8::CFunctionInfo(rcget_avphys_pages, 1, cargsget_avphys_pages);
v8::CFunction pFget_avphys_pages = v8::CFunction((const void*)&get_avphys_pagesFast, &infoget_avphys_pages);

void signalFast(void* p, int32_t p0, void* p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargssignal[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcsignal = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infosignal = v8::CFunctionInfo(rcsignal, 4, cargssignal);
v8::CFunction pFsignal = v8::CFunction((const void*)&signalFast, &infosignal);

void getenvFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsgetenv[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcgetenv = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogetenv = v8::CFunctionInfo(rcgetenv, 3, cargsgetenv);
v8::CFunction pFgetenv = v8::CFunction((const void*)&getenvFast, &infogetenv);

void callocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargscalloc[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rccalloc = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infocalloc = v8::CFunctionInfo(rccalloc, 4, cargscalloc);
v8::CFunction pFcalloc = v8::CFunction((const void*)&callocFast, &infocalloc);

void freeFast(void* p, void* p0);
v8::CTypeInfo cargsfree[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcfree = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infofree = v8::CFunctionInfo(rcfree, 2, cargsfree);
v8::CFunction pFfree = v8::CFunction((const void*)&freeFast, &infofree);

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1);
v8::CTypeInfo cargsmemfd_create[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcmemfd_create = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomemfd_create = v8::CFunctionInfo(rcmemfd_create, 3, cargsmemfd_create);
v8::CFunction pFmemfd_create = v8::CFunction((const void*)&memfd_createFast, &infomemfd_create);



void mmapSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t v4 = Local<Integer>::Cast(args[4])->Value();
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  void* rc = mmap(v0, v1, v2, v3, v4, v5);
  Local<ArrayBuffer> ab = args[6].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void mmapFast(void* p, void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  int32_t v3 = p3;
  int32_t v4 = p4;
  uint32_t v5 = p5;
  void* r = mmap(v0, v1, v2, v3, v4, v5);
  ((void**)p_ret->data)[0] = r;

}
void munmapSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = munmap(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t munmapFast(void* p, void* p0, uint32_t p1) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  return munmap(v0, v1);
}
void getcwdSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  char* v0 = reinterpret_cast<char*>(ptr0);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  char* rc = getcwd(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((char**)ab->Data())[0] = rc;
}

void getcwdFast(void* p, struct FastApiTypedArray* const p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  char* v0 = reinterpret_cast<char*>(p0->data);
  int32_t v1 = p1;
  char* r = getcwd(v0, v1);
  ((char**)p_ret->data)[0] = r;

}
void eventfdSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = eventfd(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t eventfdFast(void* p, uint32_t p0, int32_t p1) {
  uint32_t v0 = p0;
  int32_t v1 = p1;
  return eventfd(v0, v1);
}
void clock_gettimeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  timespec* v1 = reinterpret_cast<timespec*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = clock_gettime(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t clock_gettimeFast(void* p, int32_t p0, void* p1) {
  int32_t v0 = p0;
  timespec* v1 = reinterpret_cast<timespec*>(p1);
  return clock_gettime(v0, v1);
}
void mprotectSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = mprotect(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t mprotectFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return mprotect(v0, v1, v2);
}
void memcpySlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memcpy(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memcpyFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memcpy(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void memmoveSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memmove(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memmoveFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memmove(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void exitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  exit(v0);
}

void exitFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  exit(v0);
}
void usleepSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = usleep(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t usleepFast(void* p, uint32_t p0) {
  uint32_t v0 = p0;
  return usleep(v0);
}
void getpidSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  int32_t rc = getpid();
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t getpidFast(void* p) {

  return getpid();
}
void getrusageSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct rusage* v1 = reinterpret_cast<struct rusage*>(ptr1);
  int32_t rc = getrusage(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t getrusageFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct rusage* v1 = reinterpret_cast<struct rusage*>(p1->data);
  return getrusage(v0, v1);
}
void timerfd_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = timerfd_create(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t timerfd_createFast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return timerfd_create(v0, v1);
}
void sleepSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t rc = sleep(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t sleepFast(void* p, uint32_t p0) {
  uint32_t v0 = p0;
  return sleep(v0);
}
void timerfd_settimeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  const struct itimerspec* v2 = reinterpret_cast<const struct itimerspec*>(ptr2);
  struct itimerspec* v3 = reinterpret_cast<struct itimerspec*>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  int32_t rc = timerfd_settime(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t timerfd_settimeFast(void* p, int32_t p0, int32_t p1, struct FastApiTypedArray* const p2, void* p3) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  const struct itimerspec* v2 = reinterpret_cast<const struct itimerspec*>(p2->data);
  struct itimerspec* v3 = reinterpret_cast<struct itimerspec*>(p3);
  return timerfd_settime(v0, v1, v2, v3);
}
void forkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  int32_t rc = fork();
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t forkFast(void* p) {

  return fork();
}
void killSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = kill(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t killFast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return kill(v0, v1);
}
void waitpidSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  int* v1 = reinterpret_cast<int*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = waitpid(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t waitpidFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  int* v1 = reinterpret_cast<int*>(p1->data);
  int32_t v2 = p2;
  return waitpid(v0, v1, v2);
}
void execvpSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  int32_t rc = execvp(*v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t execvpFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  return execvp(v0->data, v1);
}
void readlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* v1 = reinterpret_cast<char*>(ptr1);
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = readlink(*v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, uint32_t p2) {
  struct FastOneByteString* const v0 = p0;
  char* v1 = reinterpret_cast<char*>(p1->data);
  uint32_t v2 = p2;
  return readlink(v0->data, v1, v2);
}
void sysconfSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t rc = sysconf(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t sysconfFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return sysconf(v0);
}
void pidfd_openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = syscall(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t pidfd_openFast(void* p, int32_t p0, int32_t p1, uint32_t p2) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  uint32_t v2 = p2;
  return syscall(v0, v1, v2);
}
void gettidSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = syscall(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t gettidFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return syscall(v0);
}
void getrlimitSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  struct rlimit* v1 = reinterpret_cast<struct rlimit*>(ptr1);
  int32_t rc = getrlimit(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t getrlimitFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct rlimit* v1 = reinterpret_cast<struct rlimit*>(p1->data);
  return getrlimit(v0, v1);
}
void setrlimitSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  const struct rlimit* v1 = reinterpret_cast<const struct rlimit*>(ptr1);
  int32_t rc = setrlimit(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t setrlimitFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  const struct rlimit* v1 = reinterpret_cast<const struct rlimit*>(p1->data);
  return setrlimit(v0, v1);
}
void strerror_rSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* v1 = reinterpret_cast<char*>(ptr1);
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = strerror_r(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t strerror_rFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, uint32_t p2) {
  int32_t v0 = p0;
  char* v1 = reinterpret_cast<char*>(p1->data);
  uint32_t v2 = p2;
  return strerror_r(v0, v1, v2);
}
void timesSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  struct tms* v0 = reinterpret_cast<struct tms*>(ptr0);
  int32_t rc = times(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t timesFast(void* p, struct FastApiTypedArray* const p0) {
  struct tms* v0 = reinterpret_cast<struct tms*>(p0->data);
  return times(v0);
}
void sysinfoSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  struct sysinfo* v0 = reinterpret_cast<struct sysinfo*>(ptr0);
  uint32_t rc = sysinfo(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t sysinfoFast(void* p, struct FastApiTypedArray* const p0) {
  struct sysinfo* v0 = reinterpret_cast<struct sysinfo*>(p0->data);
  return sysinfo(v0);
}
void get_avphys_pagesSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  uint32_t rc = get_avphys_pages();
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t get_avphys_pagesFast(void* p) {

  return get_avphys_pages();
}
void signalSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  sighandler_t v1 = reinterpret_cast<sighandler_t>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  sighandler_t rc = signal(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((sighandler_t*)ab->Data())[0] = rc;
}

void signalFast(void* p, int32_t p0, void* p1, struct FastApiTypedArray* const p_ret) {
  int32_t v0 = p0;
  sighandler_t v1 = reinterpret_cast<sighandler_t>(p1);
  sighandler_t r = signal(v0, v1);
  ((sighandler_t*)p_ret->data)[0] = r;

}
void getenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* rc = getenv(*v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((char**)ab->Data())[0] = rc;
}

void getenvFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  char* r = getenv(v0->data);
  ((char**)p_ret->data)[0] = r;

}
void callocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = calloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void callocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = calloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  free(v0);
}

void freeFast(void* p, void* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  free(v0);
}
void memfd_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = memfd_create(*v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p1;
  return memfd_create(v0->data, v1);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "mmap", &pFmmap, mmapSlow);
  SET_FAST_METHOD(isolate, module, "munmap", &pFmunmap, munmapSlow);
  SET_FAST_METHOD(isolate, module, "getcwd", &pFgetcwd, getcwdSlow);
  SET_FAST_METHOD(isolate, module, "eventfd", &pFeventfd, eventfdSlow);
  SET_FAST_METHOD(isolate, module, "clock_gettime", &pFclock_gettime, clock_gettimeSlow);
  SET_FAST_METHOD(isolate, module, "mprotect", &pFmprotect, mprotectSlow);
  SET_FAST_METHOD(isolate, module, "memcpy", &pFmemcpy, memcpySlow);
  SET_FAST_METHOD(isolate, module, "memmove", &pFmemmove, memmoveSlow);
  SET_FAST_METHOD(isolate, module, "exit", &pFexit, exitSlow);
  SET_FAST_METHOD(isolate, module, "usleep", &pFusleep, usleepSlow);
  SET_FAST_METHOD(isolate, module, "getpid", &pFgetpid, getpidSlow);
  SET_FAST_METHOD(isolate, module, "getrusage", &pFgetrusage, getrusageSlow);
  SET_FAST_METHOD(isolate, module, "timerfd_create", &pFtimerfd_create, timerfd_createSlow);
  SET_FAST_METHOD(isolate, module, "sleep", &pFsleep, sleepSlow);
  SET_FAST_METHOD(isolate, module, "timerfd_settime", &pFtimerfd_settime, timerfd_settimeSlow);
  SET_FAST_METHOD(isolate, module, "fork", &pFfork, forkSlow);
  SET_FAST_METHOD(isolate, module, "kill", &pFkill, killSlow);
  SET_FAST_METHOD(isolate, module, "waitpid", &pFwaitpid, waitpidSlow);
  SET_FAST_METHOD(isolate, module, "execvp", &pFexecvp, execvpSlow);
  SET_FAST_METHOD(isolate, module, "readlink", &pFreadlink, readlinkSlow);
  SET_FAST_METHOD(isolate, module, "sysconf", &pFsysconf, sysconfSlow);
  SET_FAST_METHOD(isolate, module, "pidfd_open", &pFpidfd_open, pidfd_openSlow);
  SET_FAST_METHOD(isolate, module, "gettid", &pFgettid, gettidSlow);
  SET_FAST_METHOD(isolate, module, "getrlimit", &pFgetrlimit, getrlimitSlow);
  SET_FAST_METHOD(isolate, module, "setrlimit", &pFsetrlimit, setrlimitSlow);
  SET_FAST_METHOD(isolate, module, "strerror_r", &pFstrerror_r, strerror_rSlow);
  SET_FAST_METHOD(isolate, module, "times", &pFtimes, timesSlow);
  SET_FAST_METHOD(isolate, module, "sysinfo", &pFsysinfo, sysinfoSlow);
  SET_FAST_METHOD(isolate, module, "get_avphys_pages", &pFget_avphys_pages, get_avphys_pagesSlow);
  SET_FAST_METHOD(isolate, module, "signal", &pFsignal, signalSlow);
  SET_FAST_METHOD(isolate, module, "getenv", &pFgetenv, getenvSlow);
  SET_FAST_METHOD(isolate, module, "calloc", &pFcalloc, callocSlow);
  SET_FAST_METHOD(isolate, module, "free", &pFfree, freeSlow);
  SET_FAST_METHOD(isolate, module, "memfd_create", &pFmemfd_create, memfd_createSlow);

  SET_VALUE(isolate, module, "_SC_CLK_TCK", Integer::New(isolate, (uint32_t)_SC_CLK_TCK));


  SET_MODULE(isolate, target, "system", module);
}
} // namespace system
} // namespace lo

extern "C" {
  void* _register_system() {
    return (void*)lo::system::Init;
  }
}
