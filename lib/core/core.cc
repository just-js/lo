
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <unistd.h>

#include <sys/stat.h>

#include <fcntl.h>

#include <dirent.h>

#include <dlfcn.h>

#include <sys/mman.h>

#include <stdio.h>

#include <sys/wait.h>

#include <signal.h>

#include <sys/resource.h>

#include <sys/times.h>

#include <sys/reboot.h>

#include <string.h>

#include <termios.h>


#ifdef __linux__
#include <linux/reboot.h>
#include <sys/ioctl.h>
#include <dirent.h>
#include <sched.h>
#endif



#include <lo.h>

namespace lo {
namespace core {

using v8::FunctionCallbackInfo;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Integer;
using v8::Number;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::CFunction;
using v8::CTypeInfo;
using v8::Uint8Array;
using v8::CFunctionInfo;
using v8::String;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Function;
using v8::Object;
using v8::HandleScope;
using v8::BigInt;


#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

struct fastcall {
  void* wrapper;      // 0-7   :   v8 fastcall wrapper function pointer
  uint8_t result;     // 8     :   the type of the result
  uint8_t nparam;     // 9     :   the number of args (max 255) 
  uint8_t param[30];  // 10-39 :   an array of types of the arguments
  uint64_t args[32];  // 40-295:   an array of pointer slots for arguments
                      // these will be filled in dynamically by 
                      // lo::core::SlowCallback for the slow call
                      // and then the slowcall wrapper will shift them from
                      // this structure into regs + stack and make the call
                      // the first slot is reserved for the result
  void* fn;           // 296-303:  the slowcall wrapper function pointer
};

typedef void (*lo_fast_call)(void*);

inline uint8_t needsunwrap (lo::FastTypes t) {
  if (t == lo::FastTypes::buffer) return 1;
  if (t == lo::FastTypes::u32array) return 1;
  if (t == lo::FastTypes::pointer) return 1;
  if (t == lo::FastTypes::u64) return 1;
  if (t == lo::FastTypes::i64) return 1;
  return 0;
}

v8::CTypeInfo* CTypeFromV8 (uint8_t v8Type) {
  if (v8Type == lo::FastTypes::boolean)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kBool);
  if (v8Type == lo::FastTypes::i8)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::i16)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::i32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::u8)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::u16)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::u32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::f32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat32);
  if (v8Type == lo::FastTypes::f64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat64);
  if (v8Type == lo::FastTypes::i64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt64);
  if (v8Type == lo::FastTypes::u64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::iSize)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt64);
  if (v8Type == lo::FastTypes::uSize)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::pointer)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::function)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::string)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString);
  if (v8Type == lo::FastTypes::buffer) {
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint8,
      v8::CTypeInfo::SequenceType::kIsArrayBuffer, v8::CTypeInfo::Flags::kNone);
  }
  if (v8Type == lo::FastTypes::u32array) {
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32,
      v8::CTypeInfo::SequenceType::kIsArrayBuffer, v8::CTypeInfo::Flags::kNone);
  }
  return new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
}

void lo_fastcall (struct fastcall* state) {
  ((lo_fast_call)state->fn)(&state->args);
}

void SlowCallback(const FunctionCallbackInfo<Value> &args) {
  Isolate* isolate = args.GetIsolate();
  HandleScope scope(isolate);
  struct fastcall* state = (struct fastcall*)args.Data()
    .As<Object>()->GetAlignedPointerFromInternalField(1);
  int r = 1;
  int s = 0;
  char* temp_strs[100];
  for (int i = 0; i < state->nparam; i++) {
    switch (state->param[i]) {
      case FastTypes::string:
        {
          String::Utf8Value arg0(isolate, args[i]);
          temp_strs[s] = strdup(*arg0);
          state->args[r++] = (uint64_t)temp_strs[s++];
        }
        break;
      case FastTypes::u32:
        state->args[r++] = (uint32_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::u16:
        state->args[r++] = (uint16_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::u8:
        state->args[r++] = (uint8_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::boolean:
        state->args[r++] = (bool)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i32:
        state->args[r++] = (int32_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i16:
        state->args[r++] = (int16_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i8:
        state->args[r++] = (int8_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i64:
      case FastTypes::iSize:
        state->args[r++] = (int64_t)Local<Number>::Cast(args[i])->Value();
        break;
      case FastTypes::u64:
      case FastTypes::pointer:
      case FastTypes::uSize:
        state->args[r++] = (uint64_t)Local<Number>::Cast(args[i])->Value();
        break;
      case FastTypes::buffer:
        {
          Local<Uint8Array> u8 = args[i].As<Uint8Array>();
          state->args[r++] = (uint64_t)((uint8_t*)u8->Buffer()->Data() +
            u8->ByteOffset());
        }
        break;
      case FastTypes::u32array:
        {
          Local<Uint32Array> u32 = args[i].As<Uint32Array>();
          state->args[r++] = (uint64_t)((uint8_t*)u32->Buffer()->Data() +
            u32->ByteOffset());
        }
        break;
      case FastTypes::function:
        break;
      case FastTypes::f32:
        {
          float src = (float)args[i].As<v8::Number>()->Value();
          float* dst = (float*)&state->args[r++];
          *dst = src;
        }
        break;
      case FastTypes::f64:
        {
          double src = (double)args[i].As<v8::Number>()->Value();
          double* dst = (double*)&state->args[r++];
          *dst = src;
        }
        break;
    }
  }
  lo_fastcall(state);
  for (int i = 0; i < s; i++) {
    free(temp_strs[i]);
  }
  switch (state->result) {
    case FastTypes::i32:
      args.GetReturnValue().Set((int32_t)state->args[0]);
      break;
    case FastTypes::u32:
      args.GetReturnValue().Set((uint32_t)state->args[0]);
      break;
    case FastTypes::boolean:
      args.GetReturnValue().Set((bool)state->args[0]);
      break;
    case FastTypes::f32:
      {
        float* dst = (float*)&state->args[0];
        args.GetReturnValue().Set(Number::New(isolate, *dst));
      }
      break;
    case FastTypes::f64:
      {
        double* dst = (double*)&state->args[0];
        args.GetReturnValue().Set(Number::New(isolate, *dst));
      }
      break;
    case FastTypes::i64:
      {
        int64_t* res = (int64_t*)args[args.Length() - 1]
          .As<Uint32Array>()->Buffer()->Data();
        *res = state->args[0];
      }
      break;
    case FastTypes::buffer:
    case FastTypes::u32array:
    case FastTypes::u64:
    case FastTypes::pointer:
      {
        uint64_t* res = (uint64_t*)args[args.Length() - 1]
          .As<Uint32Array>()->Buffer()->Data();
        *res = state->args[0];
      }
      break;
  }
}

void bind_fastcallSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  // TODO - does integer work?
  struct fastcall* state = reinterpret_cast<struct fastcall*>(
    Local<Integer>::Cast(args[0])->Value());
  Local<ObjectTemplate> tpl = ObjectTemplate::New(isolate);
  tpl->SetInternalFieldCount(2);
  Local<Object> data = tpl->NewInstance(context).ToLocalChecked();
  data->SetAlignedPointerInInternalField(1, state);
  uint8_t unwrap = needsunwrap((FastTypes)state->result);
  int fastlen = state->nparam + 1 + unwrap;
  CTypeInfo* cargs = (CTypeInfo*)calloc(fastlen, sizeof(CTypeInfo));
  cargs[0] = CTypeInfo(CTypeInfo::Type::kV8Value);
  for (int i = 0; i < state->nparam; i++) {
    uint8_t ptype = state->param[i];
    cargs[i + 1] = *CTypeFromV8(ptype);
  }
  CTypeInfo* rc;
  if (unwrap) {
    cargs[fastlen - 1] = *CTypeFromV8(FastTypes::u32array);
    rc = CTypeFromV8(FastTypes::empty);
  } else {
    rc = CTypeFromV8((FastTypes)state->result);
  }
  CFunctionInfo* info = new CFunctionInfo(*rc, fastlen, cargs);
  CFunction* fastCFunc = new CFunction(state->wrapper, info);
  Local<FunctionTemplate> funcTemplate = FunctionTemplate::New(isolate,
    SlowCallback, data, Local<v8::Signature>(), 0, v8::ConstructorBehavior::kThrow,
    v8::SideEffectType::kHasNoSideEffect, fastCFunc
  );
  Local<Function> fun =
    funcTemplate->GetFunction(context).ToLocalChecked();
  args.GetReturnValue().Set(fun);
}

void bind_slowcallSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  struct fastcall* state = reinterpret_cast<struct fastcall*>(
    Local<Integer>::Cast(args[0])->Value());
  Local<ObjectTemplate> tpl = ObjectTemplate::New(isolate);
  tpl->SetInternalFieldCount(2);
  Local<Object> data = tpl->NewInstance(context).ToLocalChecked();
  data->SetAlignedPointerInInternalField(1, state);
  Local<FunctionTemplate> funcTemplate = FunctionTemplate::New(isolate,
    SlowCallback, data, Local<v8::Signature>(), 0, v8::ConstructorBehavior::kThrow,
    v8::SideEffectType::kHasNoSideEffect, 0
  );
  Local<Function> fun =
    funcTemplate->GetFunction(context).ToLocalChecked();
  args.GetReturnValue().Set(fun);
}

#ifdef __linux__

pid_t vexecve (const char* pathname, char* const argv[], char* const envp[]) {
  pid_t pid = vfork();
  if (pid == 0) {
    int rc = execve(pathname, argv, envp);
    exit(rc);
  }
  if (pid == -1) return pid;
  int status = 0;
  int rc = waitpid(pid, &status, 0);
  if (rc == -1) return rc;
  return status;
}

/*
we can use wait4 with rusage struct to get usage stats on waited process
https://github.com/ziglang/zig/blob/master/lib/std/process/Child.zig#L86
*/
pid_t vfexecve (int fd, char* const argv[], char* const envp[]) {
  pid_t pid = vfork();
  if (pid == 0) {
    int rc = fexecve(fd, argv, envp);
    exit(rc);
  }
  if (pid == -1) return pid;
  int status = 0;
  int rc = waitpid(pid, &status, 0);
  if (rc == -1) return rc;
  return status;
}

#endif

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

void dlopenFast(void* p, struct FastOneByteString* const p0, int32_t p1, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsdlopen[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcdlopen = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infodlopen = CFunctionInfo(rcdlopen, 4, cargsdlopen);
CFunction pFdlopen = CFunction((const void*)&dlopenFast, &infodlopen);

void dlsymFast(void* p, void* p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsdlsym[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcdlsym = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infodlsym = CFunctionInfo(rcdlsym, 4, cargsdlsym);
CFunction pFdlsym = CFunction((const void*)&dlsymFast, &infodlsym);

int32_t dlcloseFast(void* p, void* p0);
CTypeInfo cargsdlclose[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcdlclose = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infodlclose = CFunctionInfo(rcdlclose, 2, cargsdlclose);
CFunction pFdlclose = CFunction((const void*)&dlcloseFast, &infodlclose);

void dlerrorFast(void* p, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsdlerror[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcdlerror = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infodlerror = CFunctionInfo(rcdlerror, 2, cargsdlerror);
CFunction pFdlerror = CFunction((const void*)&dlerrorFast, &infodlerror);

int32_t readFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
CTypeInfo cargsread[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcread = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo inforead = CFunctionInfo(rcread, 4, cargsread);
CFunction pFread = CFunction((const void*)&readFast, &inforead);

int32_t read2Fast(void* p, int32_t p0, void* p1, int32_t p2);
CTypeInfo cargsread2[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcread2 = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo inforead2 = CFunctionInfo(rcread2, 4, cargsread2);
CFunction pFread2 = CFunction((const void*)&read2Fast, &inforead2);

int32_t writeFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
CTypeInfo cargswrite[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcwrite = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowrite = CFunctionInfo(rcwrite, 4, cargswrite);
CFunction pFwrite = CFunction((const void*)&writeFast, &infowrite);

int32_t write_stringFast(void* p, int32_t p0, struct FastOneByteString* const p1);
CTypeInfo cargswrite_string[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcwrite_string = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowrite_string = CFunctionInfo(rcwrite_string, 3, cargswrite_string);
CFunction pFwrite_string = CFunction((const void*)&write_stringFast, &infowrite_string);

int32_t putcharFast(void* p, int32_t p0);
CTypeInfo cargsputchar[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcputchar = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoputchar = CFunctionInfo(rcputchar, 2, cargsputchar);
CFunction pFputchar = CFunction((const void*)&putcharFast, &infoputchar);

int32_t getcharFast(void* p);
CTypeInfo cargsgetchar[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcgetchar = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetchar = CFunctionInfo(rcgetchar, 1, cargsgetchar);
CFunction pFgetchar = CFunction((const void*)&getcharFast, &infogetchar);

int32_t closeFast(void* p, int32_t p0);
CTypeInfo cargsclose[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcclose = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoclose = CFunctionInfo(rcclose, 2, cargsclose);
CFunction pFclose = CFunction((const void*)&closeFast, &infoclose);

int32_t preadFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2, uint32_t p3);
CTypeInfo cargspread[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcpread = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infopread = CFunctionInfo(rcpread, 5, cargspread);
CFunction pFpread = CFunction((const void*)&preadFast, &infopread);

uint32_t lseekFast(void* p, int32_t p0, uint32_t p1, int32_t p2);
CTypeInfo cargslseek[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rclseek = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infolseek = CFunctionInfo(rclseek, 4, cargslseek);
CFunction pFlseek = CFunction((const void*)&lseekFast, &infolseek);

int32_t fstatFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
CTypeInfo cargsfstat[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcfstat = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofstat = CFunctionInfo(rcfstat, 3, cargsfstat);
CFunction pFfstat = CFunction((const void*)&fstatFast, &infofstat);

int32_t fcntlFast(void* p, int32_t p0, int32_t p1, int32_t p2);
CTypeInfo cargsfcntl[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcfcntl = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofcntl = CFunctionInfo(rcfcntl, 4, cargsfcntl);
CFunction pFfcntl = CFunction((const void*)&fcntlFast, &infofcntl);

int32_t ftruncateFast(void* p, int32_t p0, uint32_t p1);
CTypeInfo cargsftruncate[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcftruncate = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoftruncate = CFunctionInfo(rcftruncate, 3, cargsftruncate);
CFunction pFftruncate = CFunction((const void*)&ftruncateFast, &infoftruncate);

int32_t mknodFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
CTypeInfo cargsmknod[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcmknod = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomknod = CFunctionInfo(rcmknod, 4, cargsmknod);
CFunction pFmknod = CFunction((const void*)&mknodFast, &infomknod);

int32_t statFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
CTypeInfo cargsstat[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcstat = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infostat = CFunctionInfo(rcstat, 3, cargsstat);
CFunction pFstat = CFunction((const void*)&statFast, &infostat);

int32_t lstatFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
CTypeInfo cargslstat[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rclstat = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infolstat = CFunctionInfo(rclstat, 3, cargslstat);
CFunction pFlstat = CFunction((const void*)&lstatFast, &infolstat);

int32_t renameFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1);
CTypeInfo cargsrename[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcrename = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo inforename = CFunctionInfo(rcrename, 3, cargsrename);
CFunction pFrename = CFunction((const void*)&renameFast, &inforename);

int32_t accessFast(void* p, struct FastOneByteString* const p0, int32_t p1);
CTypeInfo cargsaccess[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcaccess = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoaccess = CFunctionInfo(rcaccess, 3, cargsaccess);
CFunction pFaccess = CFunction((const void*)&accessFast, &infoaccess);

int32_t openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
CTypeInfo cargsopen[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcopen = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoopen = CFunctionInfo(rcopen, 4, cargsopen);
CFunction pFopen = CFunction((const void*)&openFast, &infoopen);

int32_t unlinkFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargsunlink[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcunlink = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infounlink = CFunctionInfo(rcunlink, 2, cargsunlink);
CFunction pFunlink = CFunction((const void*)&unlinkFast, &infounlink);

void readdirFast(void* p, void* p0, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsreaddir[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcreaddir = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo inforeaddir = CFunctionInfo(rcreaddir, 3, cargsreaddir);
CFunction pFreaddir = CFunction((const void*)&readdirFast, &inforeaddir);

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, uint32_t p2);
CTypeInfo cargsreadlink[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcreadlink = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo inforeadlink = CFunctionInfo(rcreadlink, 4, cargsreadlink);
CFunction pFreadlink = CFunction((const void*)&readlinkFast, &inforeadlink);

void opendirFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsopendir[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcopendir = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoopendir = CFunctionInfo(rcopendir, 3, cargsopendir);
CFunction pFopendir = CFunction((const void*)&opendirFast, &infoopendir);

int32_t fstatatFast(void* p, int32_t p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p2, int32_t p3);
CTypeInfo cargsfstatat[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcfstatat = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofstatat = CFunctionInfo(rcfstatat, 5, cargsfstatat);
CFunction pFfstatat = CFunction((const void*)&fstatatFast, &infofstatat);

int32_t mkdirFast(void* p, struct FastOneByteString* const p0, uint32_t p1);
CTypeInfo cargsmkdir[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcmkdir = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomkdir = CFunctionInfo(rcmkdir, 3, cargsmkdir);
CFunction pFmkdir = CFunction((const void*)&mkdirFast, &infomkdir);

int32_t rmdirFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargsrmdir[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcrmdir = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo informdir = CFunctionInfo(rcrmdir, 2, cargsrmdir);
CFunction pFrmdir = CFunction((const void*)&rmdirFast, &informdir);

int32_t closedirFast(void* p, void* p0);
CTypeInfo cargsclosedir[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcclosedir = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoclosedir = CFunctionInfo(rcclosedir, 2, cargsclosedir);
CFunction pFclosedir = CFunction((const void*)&closedirFast, &infoclosedir);

int32_t chdirFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargschdir[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcchdir = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infochdir = CFunctionInfo(rcchdir, 2, cargschdir);
CFunction pFchdir = CFunction((const void*)&chdirFast, &infochdir);

int32_t fchdirFast(void* p, int32_t p0);
CTypeInfo cargsfchdir[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcfchdir = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofchdir = CFunctionInfo(rcfchdir, 2, cargsfchdir);
CFunction pFfchdir = CFunction((const void*)&fchdirFast, &infofchdir);

int32_t mprotectFast(void* p, void* p0, uint32_t p1, int32_t p2);
CTypeInfo cargsmprotect[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcmprotect = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomprotect = CFunctionInfo(rcmprotect, 4, cargsmprotect);
CFunction pFmprotect = CFunction((const void*)&mprotectFast, &infomprotect);

void memcpyFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsmemcpy[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcmemcpy = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemcpy = CFunctionInfo(rcmemcpy, 5, cargsmemcpy);
CFunction pFmemcpy = CFunction((const void*)&memcpyFast, &infomemcpy);

void memsetFast(void* p, void* p0, int32_t p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsmemset[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcmemset = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemset = CFunctionInfo(rcmemset, 5, cargsmemset);
CFunction pFmemset = CFunction((const void*)&memsetFast, &infomemset);

void memmoveFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsmemmove[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcmemmove = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemmove = CFunctionInfo(rcmemmove, 5, cargsmemmove);
CFunction pFmemmove = CFunction((const void*)&memmoveFast, &infomemmove);

int32_t shm_openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
CTypeInfo cargsshm_open[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcshm_open = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoshm_open = CFunctionInfo(rcshm_open, 4, cargsshm_open);
CFunction pFshm_open = CFunction((const void*)&shm_openFast, &infoshm_open);

int32_t shm_unlinkFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargsshm_unlink[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcshm_unlink = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoshm_unlink = CFunctionInfo(rcshm_unlink, 2, cargsshm_unlink);
CFunction pFshm_unlink = CFunction((const void*)&shm_unlinkFast, &infoshm_unlink);

void mmapFast(void* p, void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsmmap[8] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcmmap = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infommap = CFunctionInfo(rcmmap, 8, cargsmmap);
CFunction pFmmap = CFunction((const void*)&mmapFast, &infommap);

int32_t munmapFast(void* p, void* p0, uint32_t p1);
CTypeInfo cargsmunmap[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcmunmap = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomunmap = CFunctionInfo(rcmunmap, 3, cargsmunmap);
CFunction pFmunmap = CFunction((const void*)&munmapFast, &infomunmap);

int32_t msyncFast(void* p, void* p0, uint32_t p1, int32_t p2);
CTypeInfo cargsmsync[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcmsync = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomsync = CFunctionInfo(rcmsync, 4, cargsmsync);
CFunction pFmsync = CFunction((const void*)&msyncFast, &infomsync);

void mallocFast(void* p, uint32_t p0, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsmalloc[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcmalloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomalloc = CFunctionInfo(rcmalloc, 3, cargsmalloc);
CFunction pFmalloc = CFunction((const void*)&mallocFast, &infomalloc);

void callocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
CTypeInfo cargscalloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rccalloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infocalloc = CFunctionInfo(rccalloc, 4, cargscalloc);
CFunction pFcalloc = CFunction((const void*)&callocFast, &infocalloc);

void reallocFast(void* p, void* p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsrealloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcrealloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo inforealloc = CFunctionInfo(rcrealloc, 4, cargsrealloc);
CFunction pFrealloc = CFunction((const void*)&reallocFast, &inforealloc);

void aligned_allocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsaligned_alloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcaligned_alloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoaligned_alloc = CFunctionInfo(rcaligned_alloc, 4, cargsaligned_alloc);
CFunction pFaligned_alloc = CFunction((const void*)&aligned_allocFast, &infoaligned_alloc);

void freeFast(void* p, void* p0);
CTypeInfo cargsfree[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcfree = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infofree = CFunctionInfo(rcfree, 2, cargsfree);
CFunction pFfree = CFunction((const void*)&freeFast, &infofree);

void fastcallFast(void* p, void* p0);
CTypeInfo cargsfastcall[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcfastcall = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infofastcall = CFunctionInfo(rcfastcall, 2, cargsfastcall);
CFunction pFfastcall = CFunction((const void*)&fastcallFast, &infofastcall);

void getenvFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsgetenv[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcgetenv = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infogetenv = CFunctionInfo(rcgetenv, 3, cargsgetenv);
CFunction pFgetenv = CFunction((const void*)&getenvFast, &infogetenv);

int32_t setenvFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1, int32_t p2);
CTypeInfo cargssetenv[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcsetenv = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infosetenv = CFunctionInfo(rcsetenv, 4, cargssetenv);
CFunction pFsetenv = CFunction((const void*)&setenvFast, &infosetenv);

int32_t unsetenvFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargsunsetenv[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcunsetenv = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infounsetenv = CFunctionInfo(rcunsetenv, 2, cargsunsetenv);
CFunction pFunsetenv = CFunction((const void*)&unsetenvFast, &infounsetenv);

void sleepFast(void* p, int32_t p0);
CTypeInfo cargssleep[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcsleep = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infosleep = CFunctionInfo(rcsleep, 2, cargssleep);
CFunction pFsleep = CFunction((const void*)&sleepFast, &infosleep);

int32_t usleepFast(void* p, uint32_t p0);
CTypeInfo cargsusleep[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcusleep = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infousleep = CFunctionInfo(rcusleep, 2, cargsusleep);
CFunction pFusleep = CFunction((const void*)&usleepFast, &infousleep);

int32_t dupFast(void* p, int32_t p0);
CTypeInfo cargsdup[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcdup = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infodup = CFunctionInfo(rcdup, 2, cargsdup);
CFunction pFdup = CFunction((const void*)&dupFast, &infodup);

int32_t dup2Fast(void* p, int32_t p0, int32_t p1);
CTypeInfo cargsdup2[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcdup2 = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infodup2 = CFunctionInfo(rcdup2, 3, cargsdup2);
CFunction pFdup2 = CFunction((const void*)&dup2Fast, &infodup2);

void getcwdFast(void* p, void* p0, int32_t p1, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsgetcwd[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcgetcwd = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infogetcwd = CFunctionInfo(rcgetcwd, 4, cargsgetcwd);
CFunction pFgetcwd = CFunction((const void*)&getcwdFast, &infogetcwd);

int32_t getpidFast(void* p);
CTypeInfo cargsgetpid[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcgetpid = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetpid = CFunctionInfo(rcgetpid, 1, cargsgetpid);
CFunction pFgetpid = CFunction((const void*)&getpidFast, &infogetpid);

int32_t forkFast(void* p);
CTypeInfo cargsfork[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcfork = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofork = CFunctionInfo(rcfork, 1, cargsfork);
CFunction pFfork = CFunction((const void*)&forkFast, &infofork);

int32_t killFast(void* p, int32_t p0, int32_t p1);
CTypeInfo cargskill[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rckill = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infokill = CFunctionInfo(rckill, 3, cargskill);
CFunction pFkill = CFunction((const void*)&killFast, &infokill);

int32_t waitpidFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
CTypeInfo cargswaitpid[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcwaitpid = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowaitpid = CFunctionInfo(rcwaitpid, 4, cargswaitpid);
CFunction pFwaitpid = CFunction((const void*)&waitpidFast, &infowaitpid);

int32_t execvpFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
CTypeInfo cargsexecvp[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcexecvp = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoexecvp = CFunctionInfo(rcexecvp, 3, cargsexecvp);
CFunction pFexecvp = CFunction((const void*)&execvpFast, &infoexecvp);

int32_t execveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2);
CTypeInfo cargsexecve[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcexecve = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoexecve = CFunctionInfo(rcexecve, 4, cargsexecve);
CFunction pFexecve = CFunction((const void*)&execveFast, &infoexecve);

int32_t isattyFast(void* p, int32_t p0);
CTypeInfo cargsisatty[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcisatty = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoisatty = CFunctionInfo(rcisatty, 2, cargsisatty);
CFunction pFisatty = CFunction((const void*)&isattyFast, &infoisatty);

int32_t tcgetattrFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
CTypeInfo cargstcgetattr[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rctcgetattr = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infotcgetattr = CFunctionInfo(rctcgetattr, 3, cargstcgetattr);
CFunction pFtcgetattr = CFunction((const void*)&tcgetattrFast, &infotcgetattr);

int32_t tcsetattrFast(void* p, int32_t p0, int32_t p1, struct FastApiTypedArray* const p2);
CTypeInfo cargstcsetattr[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rctcsetattr = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infotcsetattr = CFunctionInfo(rctcsetattr, 4, cargstcsetattr);
CFunction pFtcsetattr = CFunction((const void*)&tcsetattrFast, &infotcsetattr);

void exitFast(void* p, int32_t p0);
CTypeInfo cargsexit[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcexit = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoexit = CFunctionInfo(rcexit, 2, cargsexit);
CFunction pFexit = CFunction((const void*)&exitFast, &infoexit);

uint32_t sysconfFast(void* p, int32_t p0);
CTypeInfo cargssysconf[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcsysconf = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infosysconf = CFunctionInfo(rcsysconf, 2, cargssysconf);
CFunction pFsysconf = CFunction((const void*)&sysconfFast, &infosysconf);

int32_t getrusageFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
CTypeInfo cargsgetrusage[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcgetrusage = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetrusage = CFunctionInfo(rcgetrusage, 3, cargsgetrusage);
CFunction pFgetrusage = CFunction((const void*)&getrusageFast, &infogetrusage);

uint32_t timesFast(void* p, struct FastApiTypedArray* const p0);
CTypeInfo cargstimes[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rctimes = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infotimes = CFunctionInfo(rctimes, 2, cargstimes);
CFunction pFtimes = CFunction((const void*)&timesFast, &infotimes);

void isolate_context_destroyFast(void* p, struct FastApiTypedArray* const p0);
CTypeInfo cargsisolate_context_destroy[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcisolate_context_destroy = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoisolate_context_destroy = CFunctionInfo(rcisolate_context_destroy, 2, cargsisolate_context_destroy);
CFunction pFisolate_context_destroy = CFunction((const void*)&isolate_context_destroyFast, &infoisolate_context_destroy);

int32_t isolate_context_sizeFast(void* p);
CTypeInfo cargsisolate_context_size[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcisolate_context_size = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoisolate_context_size = CFunctionInfo(rcisolate_context_size, 1, cargsisolate_context_size);
CFunction pFisolate_context_size = CFunction((const void*)&isolate_context_sizeFast, &infoisolate_context_size);

void memmemFast(void* p, void* p0, uint32_t p1, void* p2, uint32_t p3, struct FastApiTypedArray* const p_ret);
CTypeInfo cargsmemmem[6] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone)
};
CTypeInfo rcmemmem = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemmem = CFunctionInfo(rcmemmem, 6, cargsmemmem);
CFunction pFmemmem = CFunction((const void*)&memmemFast, &infomemmem);

uint32_t strnlenFast(void* p, void* p0, uint32_t p1);
CTypeInfo cargsstrnlen[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcstrnlen = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infostrnlen = CFunctionInfo(rcstrnlen, 3, cargsstrnlen);
CFunction pFstrnlen = CFunction((const void*)&strnlenFast, &infostrnlen);

int32_t symlinkFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1);
CTypeInfo cargssymlink[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcsymlink = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infosymlink = CFunctionInfo(rcsymlink, 3, cargssymlink);
CFunction pFsymlink = CFunction((const void*)&symlinkFast, &infosymlink);

uint32_t strnlen_strFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargsstrnlen_str[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcstrnlen_str = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infostrnlen_str = CFunctionInfo(rcstrnlen_str, 2, cargsstrnlen_str);
CFunction pFstrnlen_str = CFunction((const void*)&strnlen_strFast, &infostrnlen_str);

void syncFast(void* p);
CTypeInfo cargssync[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcsync = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infosync = CFunctionInfo(rcsync, 1, cargssync);
CFunction pFsync = CFunction((const void*)&syncFast, &infosync);

#ifdef __linux__

int32_t posix_fadviseFast(void* p, int32_t p0, uint32_t p1, uint32_t p2, int32_t p3);
CTypeInfo cargsposix_fadvise[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcposix_fadvise = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoposix_fadvise = CFunctionInfo(rcposix_fadvise, 5, cargsposix_fadvise);
CFunction pFposix_fadvise = CFunction((const void*)&posix_fadviseFast, &infoposix_fadvise);

int32_t ioctlFast(void* p, int32_t p0, uint32_t p1, struct FastApiTypedArray* const p2);
CTypeInfo cargsioctl[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcioctl = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoioctl = CFunctionInfo(rcioctl, 4, cargsioctl);
CFunction pFioctl = CFunction((const void*)&ioctlFast, &infoioctl);

int32_t ioctl2Fast(void* p, int32_t p0, uint32_t p1, int32_t p2);
CTypeInfo cargsioctl2[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcioctl2 = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoioctl2 = CFunctionInfo(rcioctl2, 4, cargsioctl2);
CFunction pFioctl2 = CFunction((const void*)&ioctl2Fast, &infoioctl2);

int32_t ioctl3Fast(void* p, int32_t p0, uint32_t p1, void* p2);
CTypeInfo cargsioctl3[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcioctl3 = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoioctl3 = CFunctionInfo(rcioctl3, 4, cargsioctl3);
CFunction pFioctl3 = CFunction((const void*)&ioctl3Fast, &infoioctl3);

int32_t rebootFast(void* p, int32_t p0);
CTypeInfo cargsreboot[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcreboot = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo inforeboot = CFunctionInfo(rcreboot, 2, cargsreboot);
CFunction pFreboot = CFunction((const void*)&rebootFast, &inforeboot);

uint32_t getdentsFast(void* p, int32_t p0, void* p1, uint32_t p2);
CTypeInfo cargsgetdents[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcgetdents = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infogetdents = CFunctionInfo(rcgetdents, 4, cargsgetdents);
CFunction pFgetdents = CFunction((const void*)&getdentsFast, &infogetdents);

int32_t getaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2);
CTypeInfo cargsgetaffinity[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcgetaffinity = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetaffinity = CFunctionInfo(rcgetaffinity, 4, cargsgetaffinity);
CFunction pFgetaffinity = CFunction((const void*)&getaffinityFast, &infogetaffinity);

uint32_t copy_file_rangeFast(void* p, int32_t p0, void* p1, int32_t p2, void* p3, uint32_t p4, uint32_t p5);
CTypeInfo cargscopy_file_range[7] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rccopy_file_range = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infocopy_file_range = CFunctionInfo(rccopy_file_range, 7, cargscopy_file_range);
CFunction pFcopy_file_range = CFunction((const void*)&copy_file_rangeFast, &infocopy_file_range);

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1);
CTypeInfo cargsmemfd_create[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcmemfd_create = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomemfd_create = CFunctionInfo(rcmemfd_create, 3, cargsmemfd_create);
CFunction pFmemfd_create = CFunction((const void*)&memfd_createFast, &infomemfd_create);

int32_t setaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2);
CTypeInfo cargssetaffinity[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcsetaffinity = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infosetaffinity = CFunctionInfo(rcsetaffinity, 4, cargssetaffinity);
CFunction pFsetaffinity = CFunction((const void*)&setaffinityFast, &infosetaffinity);

int32_t vforkFast(void* p);
CTypeInfo cargsvfork[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcvfork = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infovfork = CFunctionInfo(rcvfork, 1, cargsvfork);
CFunction pFvfork = CFunction((const void*)&vforkFast, &infovfork);

int32_t vexecveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2);
CTypeInfo cargsvexecve[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcvexecve = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infovexecve = CFunctionInfo(rcvexecve, 4, cargsvexecve);
CFunction pFvexecve = CFunction((const void*)&vexecveFast, &infovexecve);

int32_t vfexecveFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2);
CTypeInfo cargsvfexecve[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
  CTypeInfo(CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsArrayBuffer, CTypeInfo::Flags::kNone),
};
CTypeInfo rcvfexecve = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infovfexecve = CFunctionInfo(rcvfexecve, 4, cargsvfexecve);
CFunction pFvfexecve = CFunction((const void*)&vfexecveFast, &infovfexecve);

int32_t getpagesizeFast(void* p);
CTypeInfo cargsgetpagesize[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcgetpagesize = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetpagesize = CFunctionInfo(rcgetpagesize, 1, cargsgetpagesize);
CFunction pFgetpagesize = CFunction((const void*)&getpagesizeFast, &infogetpagesize);

int32_t madviseFast(void* p, void* p0, uint32_t p1, int32_t p2);
CTypeInfo cargsmadvise[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcmadvise = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomadvise = CFunctionInfo(rcmadvise, 4, cargsmadvise);
CFunction pFmadvise = CFunction((const void*)&madviseFast, &infomadvise);

#endif
#ifdef __MACH__

#endif

void dlopenSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = dlopen(*v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void dlopenFast(void* p, struct FastOneByteString* const p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  void* r = dlopen(v0->data, v1);
  ((void**)p_ret->data)[0] = r;

}
void dlsymSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  String::Utf8Value v1(isolate, args[1]);
  void* rc = dlsym(v0, *v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void dlsymFast(void* p, void* p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  struct FastOneByteString* const v1 = p1;
  void* r = dlsym(v0, v1->data);
  ((void**)p_ret->data)[0] = r;

}
void dlcloseSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = dlclose(v0);
  args.GetReturnValue().Set(rc);
}

int32_t dlcloseFast(void* p, void* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  return dlclose(v0);
}
void dlerrorSlow(const FunctionCallbackInfo<Value> &args) {

  char* rc = dlerror();
  Local<ArrayBuffer> ab = args[0].As<Uint32Array>()->Buffer();
  ((char**)ab->Data())[0] = rc;
}

void dlerrorFast(void* p, struct FastApiTypedArray* const p_ret) {

  char* r = dlerror();
  ((char**)p_ret->data)[0] = r;

}
void readSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void* v1 = reinterpret_cast<void*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = read(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t readFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1->data);
  int32_t v2 = p2;
  return read(v0, v1, v2);
}
void read2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = read(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t read2Fast(void* p, int32_t p0, void* p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1);
  int32_t v2 = p2;
  return read(v0, v1, v2);
}
void writeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void* v1 = reinterpret_cast<void*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = write(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t writeFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1->data);
  int32_t v2 = p2;
  return write(v0, v1, v2);
}
void write_stringSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  String::Utf8Value v1(isolate, args[1]);
  int32_t v2 = v1.length();
  int32_t rc = write(v0, *v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t write_stringFast(void* p, int32_t p0, struct FastOneByteString* const p1) {
  int32_t v0 = p0;
  struct FastOneByteString* const v1 = p1;
  int32_t v2 = p1->length;
  return write(v0, v1->data, v2);
}
void putcharSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = putchar(v0);
  args.GetReturnValue().Set(rc);
}

int32_t putcharFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return putchar(v0);
}
void getcharSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getchar();
  args.GetReturnValue().Set(rc);
}

int32_t getcharFast(void* p) {

  return getchar();
}
void closeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = close(v0);
  args.GetReturnValue().Set(rc);
}

int32_t closeFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return close(v0);
}
void preadSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void* v1 = reinterpret_cast<void*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = pread(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t preadFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2, uint32_t p3) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1->data);
  int32_t v2 = p2;
  uint32_t v3 = p3;
  return pread(v0, v1, v2, v3);
}
void lseekSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = lseek(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t lseekFast(void* p, int32_t p0, uint32_t p1, int32_t p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return lseek(v0, v1, v2);
}
void fstatSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct stat * v1 = reinterpret_cast<struct stat *>(ptr1);
  int32_t rc = fstat(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t fstatFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct stat * v1 = reinterpret_cast<struct stat *>(p1->data);
  return fstat(v0, v1);
}
void fcntlSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = fcntl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t fcntlFast(void* p, int32_t p0, int32_t p1, int32_t p2) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return fcntl(v0, v1, v2);
}
void ftruncateSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = ftruncate(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t ftruncateFast(void* p, int32_t p0, uint32_t p1) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  return ftruncate(v0, v1);
}
void mknodSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = mknod(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t mknodFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return mknod(v0->data, v1, v2);
}
void statSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct stat * v1 = reinterpret_cast<struct stat *>(ptr1);
  int32_t rc = stat(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t statFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct stat * v1 = reinterpret_cast<struct stat *>(p1->data);
  return stat(v0->data, v1);
}
void lstatSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct stat * v1 = reinterpret_cast<struct stat *>(ptr1);
  int32_t rc = lstat(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t lstatFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct stat * v1 = reinterpret_cast<struct stat *>(p1->data);
  return lstat(v0->data, v1);
}
void renameSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  String::Utf8Value v1(isolate, args[1]);
  int32_t rc = rename(*v0, *v1);
  args.GetReturnValue().Set(rc);
}

int32_t renameFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct FastOneByteString* const v1 = p1;
  return rename(v0->data, v1->data);
}
void accessSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = access(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t accessFast(void* p, struct FastOneByteString* const p0, int32_t p1) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  return access(v0->data, v1);
}
void openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = open(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return open(v0->data, v1, v2);
}
void unlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = unlink(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t unlinkFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return unlink(v0->data);
}
void readdirSlow(const FunctionCallbackInfo<Value> &args) {
  DIR* v0 = reinterpret_cast<DIR*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  dirent* rc = readdir(v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((dirent**)ab->Data())[0] = rc;
}

void readdirFast(void* p, void* p0, struct FastApiTypedArray* const p_ret) {
  DIR* v0 = reinterpret_cast<DIR*>(p0);
  dirent* r = readdir(v0);
  ((dirent**)p_ret->data)[0] = r;

}
void readlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* v1 = reinterpret_cast<char*>(ptr1);
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = readlink(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, uint32_t p2) {
  struct FastOneByteString* const v0 = p0;
  char* v1 = reinterpret_cast<char*>(p1->data);
  uint32_t v2 = p2;
  return readlink(v0->data, v1, v2);
}
void opendirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  DIR* rc = opendir(*v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((DIR**)ab->Data())[0] = rc;
}

void opendirFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  DIR* r = opendir(v0->data);
  ((DIR**)p_ret->data)[0] = r;

}
void fstatatSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  String::Utf8Value v1(isolate, args[1]);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  struct stat * v2 = reinterpret_cast<struct stat *>(ptr2);
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = fstatat(v0, *v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t fstatatFast(void* p, int32_t p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p2, int32_t p3) {
  int32_t v0 = p0;
  struct FastOneByteString* const v1 = p1;
  struct stat * v2 = reinterpret_cast<struct stat *>(p2->data);
  int32_t v3 = p3;
  return fstatat(v0, v1->data, v2, v3);
}
void mkdirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = mkdir(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t mkdirFast(void* p, struct FastOneByteString* const p0, uint32_t p1) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p1;
  return mkdir(v0->data, v1);
}
void rmdirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = rmdir(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t rmdirFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return rmdir(v0->data);
}
void closedirSlow(const FunctionCallbackInfo<Value> &args) {
  DIR* v0 = reinterpret_cast<DIR*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = closedir(v0);
  args.GetReturnValue().Set(rc);
}

int32_t closedirFast(void* p, void* p0) {
  DIR* v0 = reinterpret_cast<DIR*>(p0);
  return closedir(v0);
}
void chdirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = chdir(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t chdirFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return chdir(v0->data);
}
void fchdirSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = fchdir(v0);
  args.GetReturnValue().Set(rc);
}

int32_t fchdirFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return fchdir(v0);
}
void mprotectSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = mprotect(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t mprotectFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return mprotect(v0, v1, v2);
}
void memcpySlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memcpy(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memcpyFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memcpy(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void memsetSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memset(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memsetFast(void* p, void* p0, int32_t p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  int32_t v1 = p1;
  uint32_t v2 = p2;
  void* r = memset(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void memmoveSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memmove(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memmoveFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memmove(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void shm_openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = shm_open(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t shm_openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return shm_open(v0->data, v1, v2);
}
void shm_unlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = shm_unlink(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t shm_unlinkFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return shm_unlink(v0->data);
}
void mmapSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t v4 = Local<Integer>::Cast(args[4])->Value();
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  void* rc = mmap(v0, v1, v2, v3, v4, v5);
  Local<ArrayBuffer> ab = args[6].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void mmapFast(void* p, void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  int32_t v3 = p3;
  int32_t v4 = p4;
  uint32_t v5 = p5;
  void* r = mmap(v0, v1, v2, v3, v4, v5);
  ((void**)p_ret->data)[0] = r;

}
void munmapSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = munmap(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t munmapFast(void* p, void* p0, uint32_t p1) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  return munmap(v0, v1);
}
void msyncSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = msync(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t msyncFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return msync(v0, v1, v2);
}
void mallocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* rc = malloc(v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void mallocFast(void* p, uint32_t p0, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  void* r = malloc(v0);
  ((void**)p_ret->data)[0] = r;

}
void callocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = calloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void callocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = calloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void reallocSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = realloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void reallocFast(void* p, void* p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  void* r = realloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void aligned_allocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = aligned_alloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void aligned_allocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = aligned_alloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  free(v0);
}

void freeFast(void* p, void* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  free(v0);
}
void fastcallSlow(const FunctionCallbackInfo<Value> &args) {
  struct fastcall* v0 = reinterpret_cast<struct fastcall*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_fastcall(v0);
}

void fastcallFast(void* p, void* p0) {
  struct fastcall* v0 = reinterpret_cast<struct fastcall*>(p0);
  lo_fastcall(v0);
}
void getenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* rc = getenv(*v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((char**)ab->Data())[0] = rc;
}

void getenvFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  char* r = getenv(v0->data);
  ((char**)p_ret->data)[0] = r;

}
void setenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  String::Utf8Value v1(isolate, args[1]);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = setenv(*v0, *v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t setenvFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  struct FastOneByteString* const v1 = p1;
  int32_t v2 = p2;
  return setenv(v0->data, v1->data, v2);
}
void unsetenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = unsetenv(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t unsetenvFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return unsetenv(v0->data);
}
void sleepSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  sleep(v0);
}

void sleepFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  sleep(v0);
}
void usleepSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = usleep(v0);
  args.GetReturnValue().Set(rc);
}

int32_t usleepFast(void* p, uint32_t p0) {
  uint32_t v0 = p0;
  return usleep(v0);
}
void dupSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = dup(v0);
  args.GetReturnValue().Set(rc);
}

int32_t dupFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return dup(v0);
}
void dup2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = dup2(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t dup2Fast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return dup2(v0, v1);
}
void getcwdSlow(const FunctionCallbackInfo<Value> &args) {
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = getcwd(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void getcwdFast(void* p, void* p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  char* v0 = reinterpret_cast<char*>(p0);
  int32_t v1 = p1;
  void* r = getcwd(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void getpidSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getpid();
  args.GetReturnValue().Set(rc);
}

int32_t getpidFast(void* p) {

  return getpid();
}
void forkSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = fork();
  args.GetReturnValue().Set(rc);
}

int32_t forkFast(void* p) {

  return fork();
}
void killSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = kill(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t killFast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return kill(v0, v1);
}
void waitpidSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  int* v1 = reinterpret_cast<int*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = waitpid(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t waitpidFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  int* v1 = reinterpret_cast<int*>(p1->data);
  int32_t v2 = p2;
  return waitpid(v0, v1, v2);
}
void execvpSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  int32_t rc = execvp(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t execvpFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  return execvp(v0->data, v1);
}
void execveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  char* const* v2 = reinterpret_cast<char* const*>(ptr2);
  int32_t rc = execve(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t execveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  char* const* v2 = reinterpret_cast<char* const*>(p2->data);
  return execve(v0->data, v1, v2);
}
void isattySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = isatty(v0);
  args.GetReturnValue().Set(rc);
}

int32_t isattyFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return isatty(v0);
}
void tcgetattrSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct termios * v1 = reinterpret_cast<struct termios *>(ptr1);
  int32_t rc = tcgetattr(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t tcgetattrFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct termios * v1 = reinterpret_cast<struct termios *>(p1->data);
  return tcgetattr(v0, v1);
}
void tcsetattrSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  struct termios * v2 = reinterpret_cast<struct termios *>(ptr2);
  int32_t rc = tcsetattr(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t tcsetattrFast(void* p, int32_t p0, int32_t p1, struct FastApiTypedArray* const p2) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  struct termios * v2 = reinterpret_cast<struct termios *>(p2->data);
  return tcsetattr(v0, v1, v2);
}
void exitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  exit(v0);
}

void exitFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  exit(v0);
}
void sysconfSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t rc = sysconf(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t sysconfFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return sysconf(v0);
}
void getrusageSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct rusage* v1 = reinterpret_cast<struct rusage*>(ptr1);
  int32_t rc = getrusage(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t getrusageFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct rusage* v1 = reinterpret_cast<struct rusage*>(p1->data);
  return getrusage(v0, v1);
}
void timesSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  struct tms* v0 = reinterpret_cast<struct tms*>(ptr0);
  uint32_t rc = times(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t timesFast(void* p, struct FastApiTypedArray* const p0) {
  struct tms* v0 = reinterpret_cast<struct tms*>(p0->data);
  return times(v0);
}
void isolate_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  char** v1 = reinterpret_cast<char**>(ptr1);
  String::Utf8Value v2(isolate, args[2]);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  String::Utf8Value v4(isolate, args[4]);
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  Local<Uint8Array> u86 = args[6].As<Uint8Array>();
  uint8_t* ptr6 = (uint8_t*)u86->Buffer()->Data() + u86->ByteOffset();
  char* v6 = reinterpret_cast<char*>(ptr6);
  int32_t v7 = Local<Integer>::Cast(args[7])->Value();
  int32_t v8 = Local<Integer>::Cast(args[8])->Value();
  uint64_t v9 = Local<Integer>::Cast(args[9])->Value();
  String::Utf8Value v10(isolate, args[10]);
  String::Utf8Value v11(isolate, args[11]);
  int32_t v12 = Local<Integer>::Cast(args[12])->Value();
  int32_t v13 = Local<Integer>::Cast(args[13])->Value();
  void* v14 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[14])->Value());
  int32_t rc = lo_create_isolate(v0, v1, *v2, v3, *v4, v5, v6, v7, v8, v9, *v10, *v11, v12, v13, v14);
  args.GetReturnValue().Set(rc);
}

void isolate_context_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  char** v1 = reinterpret_cast<char**>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  String::Utf8Value v2(isolate, args[2]);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  String::Utf8Value v4(isolate, args[4]);
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  char* v6 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[6])->Value());
  int32_t v7 = Local<Integer>::Cast(args[7])->Value();
  int32_t v8 = Local<Integer>::Cast(args[8])->Value();
  uint64_t v9 = Local<Integer>::Cast(args[9])->Value();
  String::Utf8Value v10(isolate, args[10]);
  String::Utf8Value v11(isolate, args[11]);
  int32_t v12 = Local<Integer>::Cast(args[12])->Value();
  int32_t v13 = Local<Integer>::Cast(args[13])->Value();
  void* v14 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[14])->Value());
  Local<Uint8Array> u815 = args[15].As<Uint8Array>();
  uint8_t* ptr15 = (uint8_t*)u815->Buffer()->Data() + u815->ByteOffset();
  struct isolate_context* v15 = reinterpret_cast<struct isolate_context*>(ptr15);
  lo_create_isolate_context(v0, v1, *v2, v3, *v4, v5, v6, v7, v8, v9, *v10, *v11, v12, v13, v14, v15);
}

void isolate_context_destroySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  struct isolate_context* v0 = reinterpret_cast<struct isolate_context*>(ptr0);
  lo_destroy_isolate_context(v0);
}

void isolate_context_destroyFast(void* p, struct FastApiTypedArray* const p0) {
  struct isolate_context* v0 = reinterpret_cast<struct isolate_context*>(p0->data);
  lo_destroy_isolate_context(v0);
}
void isolate_context_sizeSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = lo_context_size();
  args.GetReturnValue().Set(rc);
}

int32_t isolate_context_sizeFast(void* p) {

  return lo_context_size();
}
void isolate_startSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  void* v0 = reinterpret_cast<void*>(ptr0);
  lo_start_isolate(v0);
}

void callbackSlow(const FunctionCallbackInfo<Value> &args) {
  exec_info* v0 = reinterpret_cast<exec_info*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_callback(v0);
}

void memmemSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* v2 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  void* rc = memmem(v0, v1, v2, v3);
  Local<ArrayBuffer> ab = args[4].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memmemFast(void* p, void* p0, uint32_t p1, void* p2, uint32_t p3, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  void* v2 = reinterpret_cast<void*>(p2);
  uint32_t v3 = p3;
  void* r = memmem(v0, v1, v2, v3);
  ((void**)p_ret->data)[0] = r;

}
void strnlenSlow(const FunctionCallbackInfo<Value> &args) {
  const char* v0 = reinterpret_cast<const char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t rc = strnlen(v0, v1);
  args.GetReturnValue().Set(rc);
}

uint32_t strnlenFast(void* p, void* p0, uint32_t p1) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  uint32_t v1 = p1;
  return strnlen(v0, v1);
}
void symlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  String::Utf8Value v1(isolate, args[1]);
  int32_t rc = symlink(*v0, *v1);
  args.GetReturnValue().Set(rc);
}

int32_t symlinkFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct FastOneByteString* const v1 = p1;
  return symlink(v0->data, v1->data);
}
void strnlen_strSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = v0.length();
  uint32_t rc = strnlen(*v0, v1);
  args.GetReturnValue().Set(rc);
}

uint32_t strnlen_strFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p0->length;
  return strnlen(v0->data, v1);
}
void syncSlow(const FunctionCallbackInfo<Value> &args) {

  sync();
}

void syncFast(void* p) {

  sync();
}
#ifdef __linux__

void posix_fadviseSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = posix_fadvise(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t posix_fadviseFast(void* p, int32_t p0, uint32_t p1, uint32_t p2, int32_t p3) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  uint32_t v2 = p2;
  int32_t v3 = p3;
  return posix_fadvise(v0, v1, v2, v3);
}
void ioctlSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  void* v2 = reinterpret_cast<void*>(ptr2);
  int32_t rc = ioctl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t ioctlFast(void* p, int32_t p0, uint32_t p1, struct FastApiTypedArray* const p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  void* v2 = reinterpret_cast<void*>(p2->data);
  return ioctl(v0, v1, v2);
}
void ioctl2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = ioctl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t ioctl2Fast(void* p, int32_t p0, uint32_t p1, int32_t p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return ioctl(v0, v1, v2);
}
void ioctl3Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* v2 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = ioctl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t ioctl3Fast(void* p, int32_t p0, uint32_t p1, void* p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  void* v2 = reinterpret_cast<void*>(p2);
  return ioctl(v0, v1, v2);
}
void rebootSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = reboot(v0);
  args.GetReturnValue().Set(rc);
}

int32_t rebootFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return reboot(v0);
}
void getdentsSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = getdents64(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t getdentsFast(void* p, int32_t p0, void* p1, uint32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  return getdents64(v0, v1, v2);
}
void getaffinitySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = sched_getaffinity(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t getaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>(p2);
  return sched_getaffinity(v0, v1, v2);
}
void copy_file_rangeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  loff_t* v1 = reinterpret_cast<loff_t*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  loff_t* v3 = reinterpret_cast<loff_t*>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  uint32_t v4 = Local<Integer>::Cast(args[4])->Value();
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  uint32_t rc = copy_file_range(v0, v1, v2, v3, v4, v5);
  args.GetReturnValue().Set(rc);
}

uint32_t copy_file_rangeFast(void* p, int32_t p0, void* p1, int32_t p2, void* p3, uint32_t p4, uint32_t p5) {
  int32_t v0 = p0;
  loff_t* v1 = reinterpret_cast<loff_t*>(p1);
  int32_t v2 = p2;
  loff_t* v3 = reinterpret_cast<loff_t*>(p3);
  uint32_t v4 = p4;
  uint32_t v5 = p5;
  return copy_file_range(v0, v1, v2, v3, v4, v5);
}
void memfd_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = memfd_create(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p1;
  return memfd_create(v0->data, v1);
}
void setaffinitySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = sched_setaffinity(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t setaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>(p2);
  return sched_setaffinity(v0, v1, v2);
}
void vforkSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = vfork();
  args.GetReturnValue().Set(rc);
}

int32_t vforkFast(void* p) {

  return vfork();
}
void vexecveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  char* const* v2 = reinterpret_cast<char* const*>(ptr2);
  int32_t rc = vexecve(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t vexecveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  char* const* v2 = reinterpret_cast<char* const*>(p2->data);
  return vexecve(v0->data, v1, v2);
}
void vfexecveSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  char* const* v2 = reinterpret_cast<char* const*>(ptr2);
  int32_t rc = vfexecve(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t vfexecveFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2) {
  int32_t v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  char* const* v2 = reinterpret_cast<char* const*>(p2->data);
  return vfexecve(v0, v1, v2);
}
void getpagesizeSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getpagesize();
  args.GetReturnValue().Set(rc);
}

int32_t getpagesizeFast(void* p) {

  return getpagesize();
}
void madviseSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = madvise(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t madviseFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return madvise(v0, v1, v2);
}
#endif
#ifdef __MACH__

#endif
void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "dlopen", &pFdlopen, dlopenSlow);
  SET_FAST_METHOD(isolate, module, "dlsym", &pFdlsym, dlsymSlow);
  SET_FAST_METHOD(isolate, module, "dlclose", &pFdlclose, dlcloseSlow);
  SET_FAST_METHOD(isolate, module, "dlerror", &pFdlerror, dlerrorSlow);
  SET_FAST_METHOD(isolate, module, "read", &pFread, readSlow);
  SET_FAST_METHOD(isolate, module, "read2", &pFread2, read2Slow);
  SET_FAST_METHOD(isolate, module, "write", &pFwrite, writeSlow);
  SET_FAST_METHOD(isolate, module, "write_string", &pFwrite_string, write_stringSlow);
  SET_FAST_METHOD(isolate, module, "putchar", &pFputchar, putcharSlow);
  SET_FAST_METHOD(isolate, module, "getchar", &pFgetchar, getcharSlow);
  SET_FAST_METHOD(isolate, module, "close", &pFclose, closeSlow);
  SET_FAST_METHOD(isolate, module, "pread", &pFpread, preadSlow);
  SET_FAST_METHOD(isolate, module, "lseek", &pFlseek, lseekSlow);
  SET_FAST_METHOD(isolate, module, "fstat", &pFfstat, fstatSlow);
  SET_FAST_METHOD(isolate, module, "fcntl", &pFfcntl, fcntlSlow);
  SET_FAST_METHOD(isolate, module, "ftruncate", &pFftruncate, ftruncateSlow);
  SET_FAST_METHOD(isolate, module, "mknod", &pFmknod, mknodSlow);
  SET_FAST_METHOD(isolate, module, "stat", &pFstat, statSlow);
  SET_FAST_METHOD(isolate, module, "lstat", &pFlstat, lstatSlow);
  SET_FAST_METHOD(isolate, module, "rename", &pFrename, renameSlow);
  SET_FAST_METHOD(isolate, module, "access", &pFaccess, accessSlow);
  SET_FAST_METHOD(isolate, module, "open", &pFopen, openSlow);
  SET_FAST_METHOD(isolate, module, "unlink", &pFunlink, unlinkSlow);
  SET_FAST_METHOD(isolate, module, "readdir", &pFreaddir, readdirSlow);
  SET_FAST_METHOD(isolate, module, "readlink", &pFreadlink, readlinkSlow);
  SET_FAST_METHOD(isolate, module, "opendir", &pFopendir, opendirSlow);
  SET_FAST_METHOD(isolate, module, "fstatat", &pFfstatat, fstatatSlow);
  SET_FAST_METHOD(isolate, module, "mkdir", &pFmkdir, mkdirSlow);
  SET_FAST_METHOD(isolate, module, "rmdir", &pFrmdir, rmdirSlow);
  SET_FAST_METHOD(isolate, module, "closedir", &pFclosedir, closedirSlow);
  SET_FAST_METHOD(isolate, module, "chdir", &pFchdir, chdirSlow);
  SET_FAST_METHOD(isolate, module, "fchdir", &pFfchdir, fchdirSlow);
  SET_FAST_METHOD(isolate, module, "mprotect", &pFmprotect, mprotectSlow);
  SET_FAST_METHOD(isolate, module, "memcpy", &pFmemcpy, memcpySlow);
  SET_FAST_METHOD(isolate, module, "memset", &pFmemset, memsetSlow);
  SET_FAST_METHOD(isolate, module, "memmove", &pFmemmove, memmoveSlow);
  SET_FAST_METHOD(isolate, module, "shm_open", &pFshm_open, shm_openSlow);
  SET_FAST_METHOD(isolate, module, "shm_unlink", &pFshm_unlink, shm_unlinkSlow);
  SET_FAST_METHOD(isolate, module, "mmap", &pFmmap, mmapSlow);
  SET_FAST_METHOD(isolate, module, "munmap", &pFmunmap, munmapSlow);
  SET_FAST_METHOD(isolate, module, "msync", &pFmsync, msyncSlow);
  SET_FAST_METHOD(isolate, module, "malloc", &pFmalloc, mallocSlow);
  SET_FAST_METHOD(isolate, module, "calloc", &pFcalloc, callocSlow);
  SET_FAST_METHOD(isolate, module, "realloc", &pFrealloc, reallocSlow);
  SET_FAST_METHOD(isolate, module, "aligned_alloc", &pFaligned_alloc, aligned_allocSlow);
  SET_FAST_METHOD(isolate, module, "free", &pFfree, freeSlow);
  SET_METHOD(isolate, module, "bind_fastcall", bind_fastcallSlow);
  SET_METHOD(isolate, module, "bind_slowcall", bind_slowcallSlow);
  SET_FAST_METHOD(isolate, module, "fastcall", &pFfastcall, fastcallSlow);
  SET_FAST_METHOD(isolate, module, "getenv", &pFgetenv, getenvSlow);
  SET_FAST_METHOD(isolate, module, "setenv", &pFsetenv, setenvSlow);
  SET_FAST_METHOD(isolate, module, "unsetenv", &pFunsetenv, unsetenvSlow);
  SET_FAST_METHOD(isolate, module, "sleep", &pFsleep, sleepSlow);
  SET_FAST_METHOD(isolate, module, "usleep", &pFusleep, usleepSlow);
  SET_FAST_METHOD(isolate, module, "dup", &pFdup, dupSlow);
  SET_FAST_METHOD(isolate, module, "dup2", &pFdup2, dup2Slow);
  SET_FAST_METHOD(isolate, module, "getcwd", &pFgetcwd, getcwdSlow);
  SET_FAST_METHOD(isolate, module, "getpid", &pFgetpid, getpidSlow);
  SET_FAST_METHOD(isolate, module, "fork", &pFfork, forkSlow);
  SET_FAST_METHOD(isolate, module, "kill", &pFkill, killSlow);
  SET_FAST_METHOD(isolate, module, "waitpid", &pFwaitpid, waitpidSlow);
  SET_FAST_METHOD(isolate, module, "execvp", &pFexecvp, execvpSlow);
  SET_FAST_METHOD(isolate, module, "execve", &pFexecve, execveSlow);
  SET_FAST_METHOD(isolate, module, "isatty", &pFisatty, isattySlow);
  SET_FAST_METHOD(isolate, module, "tcgetattr", &pFtcgetattr, tcgetattrSlow);
  SET_FAST_METHOD(isolate, module, "tcsetattr", &pFtcsetattr, tcsetattrSlow);
  SET_FAST_METHOD(isolate, module, "exit", &pFexit, exitSlow);
  SET_FAST_METHOD(isolate, module, "sysconf", &pFsysconf, sysconfSlow);
  SET_FAST_METHOD(isolate, module, "getrusage", &pFgetrusage, getrusageSlow);
  SET_FAST_METHOD(isolate, module, "times", &pFtimes, timesSlow);
  SET_METHOD(isolate, module, "isolate_create", isolate_createSlow);
  SET_METHOD(isolate, module, "isolate_context_create", isolate_context_createSlow);
  SET_FAST_METHOD(isolate, module, "isolate_context_destroy", &pFisolate_context_destroy, isolate_context_destroySlow);
  SET_FAST_METHOD(isolate, module, "isolate_context_size", &pFisolate_context_size, isolate_context_sizeSlow);
  SET_METHOD(isolate, module, "isolate_start", isolate_startSlow);
  SET_METHOD(isolate, module, "callback", callbackSlow);
  SET_FAST_METHOD(isolate, module, "memmem", &pFmemmem, memmemSlow);
  SET_FAST_METHOD(isolate, module, "strnlen", &pFstrnlen, strnlenSlow);
  SET_FAST_METHOD(isolate, module, "symlink", &pFsymlink, symlinkSlow);
  SET_FAST_METHOD(isolate, module, "strnlen_str", &pFstrnlen_str, strnlen_strSlow);
  SET_FAST_METHOD(isolate, module, "sync", &pFsync, syncSlow);

#ifdef __linux__
  SET_FAST_METHOD(isolate, module, "posix_fadvise", &pFposix_fadvise, posix_fadviseSlow);
  SET_FAST_METHOD(isolate, module, "ioctl", &pFioctl, ioctlSlow);
  SET_FAST_METHOD(isolate, module, "ioctl2", &pFioctl2, ioctl2Slow);
  SET_FAST_METHOD(isolate, module, "ioctl3", &pFioctl3, ioctl3Slow);
  SET_FAST_METHOD(isolate, module, "reboot", &pFreboot, rebootSlow);
  SET_FAST_METHOD(isolate, module, "getdents", &pFgetdents, getdentsSlow);
  SET_FAST_METHOD(isolate, module, "getaffinity", &pFgetaffinity, getaffinitySlow);
  SET_FAST_METHOD(isolate, module, "copy_file_range", &pFcopy_file_range, copy_file_rangeSlow);
  SET_FAST_METHOD(isolate, module, "memfd_create", &pFmemfd_create, memfd_createSlow);
  SET_FAST_METHOD(isolate, module, "setaffinity", &pFsetaffinity, setaffinitySlow);
  SET_FAST_METHOD(isolate, module, "vfork", &pFvfork, vforkSlow);
  SET_FAST_METHOD(isolate, module, "vexecve", &pFvexecve, vexecveSlow);
  SET_FAST_METHOD(isolate, module, "vfexecve", &pFvfexecve, vfexecveSlow);
  SET_FAST_METHOD(isolate, module, "getpagesize", &pFgetpagesize, getpagesizeSlow);
  SET_FAST_METHOD(isolate, module, "madvise", &pFmadvise, madviseSlow);

#endif
#ifdef __MACH__

#endif
  SET_VALUE(isolate, module, "S_IFBLK", Integer::New(isolate, (int32_t)S_IFBLK));
  SET_VALUE(isolate, module, "S_IFCHR", Integer::New(isolate, (int32_t)S_IFCHR));
  SET_VALUE(isolate, module, "S_IFIFO", Integer::New(isolate, (int32_t)S_IFIFO));
  SET_VALUE(isolate, module, "S_IRUSR", Integer::New(isolate, (int32_t)S_IRUSR));
  SET_VALUE(isolate, module, "S_IWUSR", Integer::New(isolate, (int32_t)S_IWUSR));
  SET_VALUE(isolate, module, "S_IRGRP", Integer::New(isolate, (int32_t)S_IRGRP));
  SET_VALUE(isolate, module, "S_IWGRP", Integer::New(isolate, (int32_t)S_IWGRP));
  SET_VALUE(isolate, module, "S_IROTH", Integer::New(isolate, (int32_t)S_IROTH));
  SET_VALUE(isolate, module, "S_IWOTH", Integer::New(isolate, (int32_t)S_IWOTH));
  SET_VALUE(isolate, module, "O_RDONLY", Integer::New(isolate, (int32_t)O_RDONLY));
  SET_VALUE(isolate, module, "O_WRONLY", Integer::New(isolate, (int32_t)O_WRONLY));
  SET_VALUE(isolate, module, "O_CREAT", Integer::New(isolate, (int32_t)O_CREAT));
  SET_VALUE(isolate, module, "S_IRWXU", Integer::New(isolate, (int32_t)S_IRWXU));
  SET_VALUE(isolate, module, "S_IRWXG", Integer::New(isolate, (int32_t)S_IRWXG));
  SET_VALUE(isolate, module, "S_IXOTH", Integer::New(isolate, (int32_t)S_IXOTH));
  SET_VALUE(isolate, module, "O_TRUNC", Integer::New(isolate, (int32_t)O_TRUNC));
  SET_VALUE(isolate, module, "STDIN", Number::New(isolate, (int64_t)0));
  SET_VALUE(isolate, module, "STDOUT", Number::New(isolate, (int64_t)1));
  SET_VALUE(isolate, module, "STDERR", Number::New(isolate, (int64_t)2));
  SET_VALUE(isolate, module, "O_CLOEXEC", Integer::New(isolate, (int32_t)O_CLOEXEC));
  SET_VALUE(isolate, module, "RUSAGE_SELF", Integer::New(isolate, (int32_t)RUSAGE_SELF));
  SET_VALUE(isolate, module, "SEEK_SET", Integer::New(isolate, (int32_t)SEEK_SET));
  SET_VALUE(isolate, module, "SEEK_CUR", Integer::New(isolate, (int32_t)SEEK_CUR));
  SET_VALUE(isolate, module, "SEEK_END", Integer::New(isolate, (int32_t)SEEK_END));
  SET_VALUE(isolate, module, "S_IRWXO", Integer::New(isolate, (int32_t)S_IRWXO));
  SET_VALUE(isolate, module, "F_OK", Integer::New(isolate, (int32_t)F_OK));
  SET_VALUE(isolate, module, "S_IFMT", Integer::New(isolate, (int32_t)S_IFMT));
  SET_VALUE(isolate, module, "S_IFDIR", Integer::New(isolate, (int32_t)S_IFDIR));
  SET_VALUE(isolate, module, "S_IFREG", Integer::New(isolate, (int32_t)S_IFREG));
  SET_VALUE(isolate, module, "NAME_MAX", Integer::New(isolate, (uint32_t)NAME_MAX));
  SET_VALUE(isolate, module, "O_RDWR", Integer::New(isolate, (int32_t)O_RDWR));
  SET_VALUE(isolate, module, "O_SYNC", Integer::New(isolate, (int32_t)O_SYNC));
  SET_VALUE(isolate, module, "O_DIRECTORY", Integer::New(isolate, (int32_t)O_DIRECTORY));
  SET_VALUE(isolate, module, "F_SETFL", Integer::New(isolate, (int32_t)F_SETFL));
  SET_VALUE(isolate, module, "O_NONBLOCK", Integer::New(isolate, (int32_t)O_NONBLOCK));
  SET_VALUE(isolate, module, "EAGAIN", Integer::New(isolate, (int32_t)EAGAIN));
  SET_VALUE(isolate, module, "WNOHANG", Integer::New(isolate, (int32_t)WNOHANG));
  SET_VALUE(isolate, module, "SIGTERM", Integer::New(isolate, (int32_t)SIGTERM));
  SET_VALUE(isolate, module, "MAP_SHARED", Integer::New(isolate, (int32_t)MAP_SHARED));
  SET_VALUE(isolate, module, "MAP_ANONYMOUS", Integer::New(isolate, (int32_t)MAP_ANONYMOUS));
  SET_VALUE(isolate, module, "MAP_PRIVATE", Integer::New(isolate, (int32_t)MAP_PRIVATE));
  SET_VALUE(isolate, module, "MS_ASYNC", Integer::New(isolate, (int32_t)MS_ASYNC));
  SET_VALUE(isolate, module, "MS_SYNC", Integer::New(isolate, (int32_t)MS_SYNC));
  SET_VALUE(isolate, module, "MS_INVALIDATE", Integer::New(isolate, (int32_t)MS_INVALIDATE));
  SET_VALUE(isolate, module, "_SC_CLK_TCK", Integer::New(isolate, (int32_t)_SC_CLK_TCK));
  SET_VALUE(isolate, module, "F_GETFL", Integer::New(isolate, (int32_t)F_GETFL));
  SET_VALUE(isolate, module, "RTLD_NOW", Integer::New(isolate, (int32_t)RTLD_NOW));
  SET_VALUE(isolate, module, "RTLD_LAZY", Integer::New(isolate, (int32_t)RTLD_LAZY));
  SET_VALUE(isolate, module, "RTLD_GLOBAL", Integer::New(isolate, (int32_t)RTLD_GLOBAL));
  SET_VALUE(isolate, module, "RTLD_LOCAL", Integer::New(isolate, (int32_t)RTLD_LOCAL));
  SET_VALUE(isolate, module, "RTLD_NODELETE", Integer::New(isolate, (int32_t)RTLD_NODELETE));
  SET_VALUE(isolate, module, "RTLD_NOLOAD", Integer::New(isolate, (int32_t)RTLD_NOLOAD));
  SET_VALUE(isolate, module, "RTLD_DEFAULT", BigInt::New(isolate, (uint64_t)RTLD_DEFAULT));
  SET_VALUE(isolate, module, "RTLD_NEXT", BigInt::New(isolate, (uint64_t)RTLD_NEXT));
  SET_VALUE(isolate, module, "PROT_READ", Integer::New(isolate, (int32_t)PROT_READ));
  SET_VALUE(isolate, module, "PROT_WRITE", Integer::New(isolate, (int32_t)PROT_WRITE));
  SET_VALUE(isolate, module, "PROT_EXEC", Integer::New(isolate, (int32_t)PROT_EXEC));
  SET_VALUE(isolate, module, "_SC_PAGESIZE", Integer::New(isolate, (int32_t)_SC_PAGESIZE));
  SET_VALUE(isolate, module, "DT_BLK", Integer::New(isolate, (int32_t)DT_BLK));
  SET_VALUE(isolate, module, "DT_CHR", Integer::New(isolate, (int32_t)DT_CHR));
  SET_VALUE(isolate, module, "DT_DIR", Integer::New(isolate, (int32_t)DT_DIR));
  SET_VALUE(isolate, module, "DT_FIFO", Integer::New(isolate, (int32_t)DT_FIFO));
  SET_VALUE(isolate, module, "DT_LNK", Integer::New(isolate, (int32_t)DT_LNK));
  SET_VALUE(isolate, module, "DT_REG", Integer::New(isolate, (int32_t)DT_REG));
  SET_VALUE(isolate, module, "DT_SOCK", Integer::New(isolate, (int32_t)DT_SOCK));
  SET_VALUE(isolate, module, "DT_UNKNOWN", Integer::New(isolate, (int32_t)DT_UNKNOWN));

#ifdef __linux__
  SET_VALUE(isolate, module, "LINUX_REBOOT_CMD_HALT", Integer::New(isolate, (uint32_t)LINUX_REBOOT_CMD_HALT));
  SET_VALUE(isolate, module, "LINUX_REBOOT_CMD_POWER_OFF", Integer::New(isolate, (uint32_t)LINUX_REBOOT_CMD_POWER_OFF));
  SET_VALUE(isolate, module, "LINUX_REBOOT_CMD_RESTART", Integer::New(isolate, (uint32_t)LINUX_REBOOT_CMD_RESTART));
  SET_VALUE(isolate, module, "RB_POWER_OFF", Integer::New(isolate, (int32_t)RB_POWER_OFF));
  SET_VALUE(isolate, module, "EINTR", Integer::New(isolate, (int32_t)EINTR));
  SET_VALUE(isolate, module, "MFD_CLOEXEC", Integer::New(isolate, (int32_t)MFD_CLOEXEC));
  SET_VALUE(isolate, module, "MAP_HUGETLB", Integer::New(isolate, (int32_t)MAP_HUGETLB));
  SET_VALUE(isolate, module, "MAP_HUGE_SHIFT", Integer::New(isolate, (int32_t)MAP_HUGE_SHIFT));
  SET_VALUE(isolate, module, "MFD_HUGETLB", Integer::New(isolate, (int32_t)MFD_HUGETLB));
  SET_VALUE(isolate, module, "MADV_HUGEPAGE", Integer::New(isolate, (int32_t)MADV_HUGEPAGE));
  SET_VALUE(isolate, module, "MAP_FIXED", Integer::New(isolate, (int32_t)MAP_FIXED));
  SET_VALUE(isolate, module, "POSIX_FADV_SEQUENTIAL", Integer::New(isolate, (int32_t)POSIX_FADV_SEQUENTIAL));
  SET_VALUE(isolate, module, "POSIX_FADV_WILLNEED", Integer::New(isolate, (int32_t)POSIX_FADV_WILLNEED));
  SET_VALUE(isolate, module, "POSIX_FADV_RANDOM", Integer::New(isolate, (int32_t)POSIX_FADV_RANDOM));
  SET_VALUE(isolate, module, "POSIX_FADV_DONTNEED", Integer::New(isolate, (int32_t)POSIX_FADV_DONTNEED));

#endif
#ifdef __MACH__
  SET_VALUE(isolate, module, "RTLD_FIRST", Integer::New(isolate, (int32_t)RTLD_FIRST));
  SET_VALUE(isolate, module, "RTLD_SELF", BigInt::New(isolate, (int64_t)RTLD_SELF));
  SET_VALUE(isolate, module, "RTLD_MAIN_ONLY", BigInt::New(isolate, (int64_t)RTLD_MAIN_ONLY));
  SET_VALUE(isolate, module, "MAP_JIT", Integer::New(isolate, (int32_t)MAP_JIT));

#endif

#ifdef __MACH__
  SET_VALUE(isolate, module, "struct_clock_t_size", Integer::New(isolate, sizeof(clock_t)));
  SET_VALUE(isolate, module, "struct_fastcall_size", Integer::New(isolate, sizeof(fastcall)));

#endif
#ifdef __linux__
  SET_VALUE(isolate, module, "struct_clock_t_size", Integer::New(isolate, sizeof(clock_t)));
  SET_VALUE(isolate, module, "struct_fastcall_size", Integer::New(isolate, sizeof(fastcall)));
  SET_VALUE(isolate, module, "struct_cpu_set_t_size", Integer::New(isolate, sizeof(cpu_set_t)));

#endif
  SET_MODULE(isolate, target, "core", module);
}
} // namespace core
} // namespace lo

extern "C"  {
  DLL_PUBLIC void* _register_core() {
    return (void*)lo::core::Init;
  }
}
