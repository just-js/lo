
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <unistd.h>

#include <sys/stat.h>

#include <fcntl.h>

#include <dirent.h>

#include <dlfcn.h>

#include <sys/mman.h>

#include <stdio.h>

#include <sys/wait.h>

#include <signal.h>

#include <sys/resource.h>

#include <sys/times.h>

#include <sys/reboot.h>

#include <string.h>

#include <termios.h>


#ifdef __linux__
#include <linux/reboot.h>
#include <sys/ioctl.h>
#include <dirent.h>
#include <sched.h>
#endif

#ifdef __MACH__

#endif

#include <lo.h>

namespace lo {
namespace core {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;
using v8::BigInt;


#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

//#define MAGIC_VALUE_SIGNAL_GUEST_BOOT_COMPLETE 123

// used for firecracker startup time testing
/*
void mmio_signal (void) {
  unsigned long FIRST_ADDR_PAST_32BITS = (1UL << 32);
  unsigned long MEM_32BIT_GAP_SIZE = (768UL << 20);

  int fd = open("/dev/mem", (O_RDWR | O_SYNC | O_CLOEXEC));
  int mapped_size = getpagesize();
  char *map_base = (char *)mmap(NULL,
    mapped_size,
    PROT_WRITE,
    MAP_SHARED,
    fd,
    FIRST_ADDR_PAST_32BITS - MEM_32BIT_GAP_SIZE);
  *map_base = MAGIC_VALUE_SIGNAL_GUEST_BOOT_COMPLETE;
  msync(map_base, mapped_size, MS_SYNC);
  munmap(map_base, mapped_size);
  close(fd);
}
*/

struct fastcall {
  void* wrapper;      // 0-7   :   v8 fastcall wrapper function pointer
  uint8_t result;     // 8     :   the type of the result
  uint8_t nparam;     // 9     :   the number of args (max 255) 
  uint8_t param[30];  // 10-39 :   an array of types of the arguments
  uint64_t args[32];  // 40-295:   an array of pointer slots for arguments
                      // these will be filled in dynamically by 
                      // lo::core::SlowCallback for the slow call
                      // and then the slowcall wrapper will shift them from
                      // this structure into regs + stack and make the call
                      // the first slot is reserved for the result
  void* fn;           // 296-303:  the slowcall wrapper function pointer
};

typedef void (*lo_fast_call)(void*);

inline uint8_t needsunwrap (lo::FastTypes t) {
  if (t == lo::FastTypes::buffer) return 1;
  if (t == lo::FastTypes::u32array) return 1;
  if (t == lo::FastTypes::pointer) return 1;
  if (t == lo::FastTypes::u64) return 1;
  if (t == lo::FastTypes::i64) return 1;
  return 0;
}

v8::CTypeInfo* CTypeFromV8 (uint8_t v8Type) {
  if (v8Type == lo::FastTypes::boolean)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kBool);
  if (v8Type == lo::FastTypes::i8)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::i16)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::i32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::u8)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::u16)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::u32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::f32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat32);
  if (v8Type == lo::FastTypes::f64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat64);
  if (v8Type == lo::FastTypes::i64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt64);
  if (v8Type == lo::FastTypes::u64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::iSize)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt64);
  if (v8Type == lo::FastTypes::uSize)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::pointer)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::function)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::string)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString);
  if (v8Type == lo::FastTypes::buffer) {
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint8,
      v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  }
  if (v8Type == lo::FastTypes::u32array) {
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32,
      v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  }
  return new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
}

void lo_fastcall (struct fastcall* state) {
  ((lo_fast_call)state->fn)(&state->args);
}

void SlowCallback(const FunctionCallbackInfo<Value> &args) {
  Isolate* isolate = args.GetIsolate();
  HandleScope scope(isolate);
  struct fastcall* state = (struct fastcall*)args.Data()
    .As<Object>()->GetAlignedPointerFromInternalField(1);
/*
  int r = 1;
  for (int i = 0; i < state->nparam; i++) {
    if (state->param[i] == FastTypes::string) {
      String::Utf8Value arg0(isolate, args[i]);
      state->args[r++] = (uint64_t)*arg0;
    } else if (state->param[i] == FastTypes::u32) {
      state->args[r++] = (uint32_t)Local<Integer>::Cast(args[i])->Value();
    } else if (state->param[i] == FastTypes::i32) {
      state->args[r++] = (int32_t)Local<Integer>::Cast(args[i])->Value();
    }
  }
*/
  int r = 1;
  for (int i = 0; i < state->nparam; i++) {
    switch (state->param[i]) {
    // we need to know if the strings are const or not
    // do we always have to copy? how do we clean up?
    // why can't we take the copy on the stack and have it cleaned
    // up automatically?
      case FastTypes::string:
        {
          String::Utf8Value arg0(isolate, args[i]);
          // todo: fix this - never gets freed
//          state->args[r++] = (uint64_t)*arg0;
          state->args[r++] = (uint64_t)strdup(*arg0);
        }
        break;
      case FastTypes::u32:
        state->args[r++] = (uint32_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::u16:
        state->args[r++] = (uint16_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::u8:
        state->args[r++] = (uint8_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::boolean:
        state->args[r++] = (bool)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i32:
        state->args[r++] = (int32_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i16:
        state->args[r++] = (int16_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i8:
        state->args[r++] = (int8_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i64:
      case FastTypes::iSize:
        state->args[r++] = (int64_t)Local<Number>::Cast(args[i])->Value();
        break;
      case FastTypes::u64:
      case FastTypes::pointer:
      case FastTypes::uSize:
        state->args[r++] = (uint64_t)Local<Number>::Cast(args[i])->Value();
        break;
      case FastTypes::buffer:
        {
          Local<Uint8Array> u8 = args[i].As<Uint8Array>();
          state->args[r++] = (uint64_t)((uint8_t*)u8->Buffer()->Data() +
            u8->ByteOffset());
        }
        break;
      case FastTypes::u32array:
        {
          Local<Uint32Array> u32 = args[i].As<Uint32Array>();
          state->args[r++] = (uint64_t)((uint8_t*)u32->Buffer()->Data() +
            u32->ByteOffset());
        }
        break;
      case FastTypes::function:
        break;
      case FastTypes::f32:
        {
          float src = (float)args[i].As<v8::Number>()->Value();
          float* dst = (float*)&state->args[r++];
          *dst = src;
        }
        break;
      case FastTypes::f64:
        {
          //Local<Uint32Array> u32 = args[i].As<Uint32Array>();
          //state->args[r++] = (uint64_t)((uint8_t*)u32->Buffer()->Data() +
          //  u32->ByteOffset());
          double src = (double)args[i].As<v8::Number>()->Value();
          double* dst = (double*)&state->args[r++];
          *dst = src;
        }
        break;
    }
  }
  lo_fastcall(state);
  switch (state->result) {
    case FastTypes::i32:
      args.GetReturnValue().Set((int32_t)state->args[0]);
      break;
    case FastTypes::u32:
      args.GetReturnValue().Set((uint32_t)state->args[0]);
      break;
    case FastTypes::boolean:
      args.GetReturnValue().Set((bool)state->args[0]);
      break;
    case FastTypes::f32:
      {
        float* dst = (float*)&state->args[0];
        args.GetReturnValue().Set(Number::New(isolate, *dst));
      }
      break;
    case FastTypes::f64:
      {
        //double* res = (double*)args[args.Length() - 1]
        //  .As<Uint32Array>()->Buffer()->Data();
        //*res = state->args[0];
        double* dst = (double*)&state->args[0];
        args.GetReturnValue().Set(Number::New(isolate, *dst));
      }
      break;
    case FastTypes::i64:
      {
        int64_t* res = (int64_t*)args[args.Length() - 1]
          .As<Uint32Array>()->Buffer()->Data();
        *res = state->args[0];
      }
      break;
    case FastTypes::buffer:
    case FastTypes::u32array:
    case FastTypes::u64:
    case FastTypes::pointer:
      {
        uint64_t* res = (uint64_t*)args[args.Length() - 1]
          .As<Uint32Array>()->Buffer()->Data();
        *res = state->args[0];
      }
      break;
  }
}

void bind_fastcallSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  // TODO - does integer work?
  struct fastcall* state = reinterpret_cast<struct fastcall*>(
    Local<Integer>::Cast(args[0])->Value());
  Local<ObjectTemplate> tpl = ObjectTemplate::New(isolate);
  tpl->SetInternalFieldCount(2);
  Local<Object> data = tpl->NewInstance(context).ToLocalChecked();
  data->SetAlignedPointerInInternalField(1, state);
  uint8_t unwrap = needsunwrap((FastTypes)state->result);
  int fastlen = state->nparam + 1 + unwrap;
  CTypeInfo* cargs = (CTypeInfo*)calloc(fastlen, sizeof(CTypeInfo));
  cargs[0] = CTypeInfo(CTypeInfo::Type::kV8Value);
  for (int i = 0; i < state->nparam; i++) {
    uint8_t ptype = state->param[i];
    cargs[i + 1] = *CTypeFromV8(ptype);
  }
  CTypeInfo* rc;
  if (unwrap) {
    cargs[fastlen - 1] = *CTypeFromV8(FastTypes::u32array);
    rc = CTypeFromV8(FastTypes::empty);
  } else {
    rc = CTypeFromV8((FastTypes)state->result);
  }
  CFunctionInfo* info = new CFunctionInfo(*rc, fastlen, cargs);
  CFunction* fastCFunc = new CFunction(state->wrapper, info);
  Local<FunctionTemplate> funcTemplate = FunctionTemplate::New(isolate,
    SlowCallback, data, Local<Signature>(), 0, ConstructorBehavior::kThrow,
    SideEffectType::kHasNoSideEffect, fastCFunc
  );
  Local<Function> fun =
    funcTemplate->GetFunction(context).ToLocalChecked();
  args.GetReturnValue().Set(fun);
}

void bind_slowcallSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  struct fastcall* state = reinterpret_cast<struct fastcall*>(
    Local<Integer>::Cast(args[0])->Value());
  Local<ObjectTemplate> tpl = ObjectTemplate::New(isolate);
  tpl->SetInternalFieldCount(2);
  Local<Object> data = tpl->NewInstance(context).ToLocalChecked();
  data->SetAlignedPointerInInternalField(1, state);
  Local<FunctionTemplate> funcTemplate = FunctionTemplate::New(isolate,
    SlowCallback, data, Local<Signature>(), 0, ConstructorBehavior::kThrow,
    SideEffectType::kHasNoSideEffect, 0
  );
  Local<Function> fun =
    funcTemplate->GetFunction(context).ToLocalChecked();
  args.GetReturnValue().Set(fun);
}

#ifdef __linux__

pid_t vexecve (const char* pathname, char* const argv[], char* const envp[]) {
  pid_t pid = vfork();
  if (pid == 0) {
    int rc = execve(pathname, argv, envp);
    exit(rc);
  }
  if (pid == -1) return pid;
  int status = 0;
  int rc = waitpid(pid, &status, 0);
  if (rc == -1) return rc;
  return status;
}

/*
we can use wait4 with rusage struct to get usage stats on waited process
https://github.com/ziglang/zig/blob/master/lib/std/process/Child.zig#L86
*/
pid_t vfexecve (int fd, char* const argv[], char* const envp[]) {
  pid_t pid = vfork();
  if (pid == 0) {
    int rc = fexecve(fd, argv, envp);
    exit(rc);
  }
  if (pid == -1) return pid;
  int status = 0;
  int rc = waitpid(pid, &status, 0);
  if (rc == -1) return rc;
  return status;
}

#endif

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

void dlopenFast(void* p, struct FastOneByteString* const p0, int32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsdlopen[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcdlopen = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infodlopen = v8::CFunctionInfo(rcdlopen, 4, cargsdlopen);
v8::CFunction pFdlopen = v8::CFunction((const void*)&dlopenFast, &infodlopen);

void dlsymFast(void* p, void* p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsdlsym[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcdlsym = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infodlsym = v8::CFunctionInfo(rcdlsym, 4, cargsdlsym);
v8::CFunction pFdlsym = v8::CFunction((const void*)&dlsymFast, &infodlsym);

int32_t dlcloseFast(void* p, void* p0);
v8::CTypeInfo cargsdlclose[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcdlclose = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infodlclose = v8::CFunctionInfo(rcdlclose, 2, cargsdlclose);
v8::CFunction pFdlclose = v8::CFunction((const void*)&dlcloseFast, &infodlclose);

int32_t readFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
v8::CTypeInfo cargsread[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcread = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo inforead = v8::CFunctionInfo(rcread, 4, cargsread);
v8::CFunction pFread = v8::CFunction((const void*)&readFast, &inforead);

int32_t read2Fast(void* p, int32_t p0, void* p1, int32_t p2);
v8::CTypeInfo cargsread2[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcread2 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo inforead2 = v8::CFunctionInfo(rcread2, 4, cargsread2);
v8::CFunction pFread2 = v8::CFunction((const void*)&read2Fast, &inforead2);

int32_t writeFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
v8::CTypeInfo cargswrite[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcwrite = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infowrite = v8::CFunctionInfo(rcwrite, 4, cargswrite);
v8::CFunction pFwrite = v8::CFunction((const void*)&writeFast, &infowrite);

int32_t write_stringFast(void* p, int32_t p0, struct FastOneByteString* const p1);
v8::CTypeInfo cargswrite_string[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcwrite_string = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infowrite_string = v8::CFunctionInfo(rcwrite_string, 3, cargswrite_string);
v8::CFunction pFwrite_string = v8::CFunction((const void*)&write_stringFast, &infowrite_string);

int32_t putcharFast(void* p, int32_t p0);
v8::CTypeInfo cargsputchar[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcputchar = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoputchar = v8::CFunctionInfo(rcputchar, 2, cargsputchar);
v8::CFunction pFputchar = v8::CFunction((const void*)&putcharFast, &infoputchar);

int32_t closeFast(void* p, int32_t p0);
v8::CTypeInfo cargsclose[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcclose = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoclose = v8::CFunctionInfo(rcclose, 2, cargsclose);
v8::CFunction pFclose = v8::CFunction((const void*)&closeFast, &infoclose);

int32_t preadFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2, uint32_t p3);
v8::CTypeInfo cargspread[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcpread = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infopread = v8::CFunctionInfo(rcpread, 5, cargspread);
v8::CFunction pFpread = v8::CFunction((const void*)&preadFast, &infopread);

uint32_t lseekFast(void* p, int32_t p0, uint32_t p1, int32_t p2);
v8::CTypeInfo cargslseek[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rclseek = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infolseek = v8::CFunctionInfo(rclseek, 4, cargslseek);
v8::CFunction pFlseek = v8::CFunction((const void*)&lseekFast, &infolseek);

int32_t fstatFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsfstat[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcfstat = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infofstat = v8::CFunctionInfo(rcfstat, 3, cargsfstat);
v8::CFunction pFfstat = v8::CFunction((const void*)&fstatFast, &infofstat);

int32_t fcntlFast(void* p, int32_t p0, int32_t p1, int32_t p2);
v8::CTypeInfo cargsfcntl[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcfcntl = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infofcntl = v8::CFunctionInfo(rcfcntl, 4, cargsfcntl);
v8::CFunction pFfcntl = v8::CFunction((const void*)&fcntlFast, &infofcntl);

int32_t ftruncateFast(void* p, int32_t p0, uint32_t p1);
v8::CTypeInfo cargsftruncate[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcftruncate = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoftruncate = v8::CFunctionInfo(rcftruncate, 3, cargsftruncate);
v8::CFunction pFftruncate = v8::CFunction((const void*)&ftruncateFast, &infoftruncate);

int32_t mknodFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
v8::CTypeInfo cargsmknod[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcmknod = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomknod = v8::CFunctionInfo(rcmknod, 4, cargsmknod);
v8::CFunction pFmknod = v8::CFunction((const void*)&mknodFast, &infomknod);

int32_t statFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsstat[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcstat = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infostat = v8::CFunctionInfo(rcstat, 3, cargsstat);
v8::CFunction pFstat = v8::CFunction((const void*)&statFast, &infostat);

int32_t lstatFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargslstat[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rclstat = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infolstat = v8::CFunctionInfo(rclstat, 3, cargslstat);
v8::CFunction pFlstat = v8::CFunction((const void*)&lstatFast, &infolstat);

int32_t renameFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1);
v8::CTypeInfo cargsrename[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcrename = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo inforename = v8::CFunctionInfo(rcrename, 3, cargsrename);
v8::CFunction pFrename = v8::CFunction((const void*)&renameFast, &inforename);

int32_t accessFast(void* p, struct FastOneByteString* const p0, int32_t p1);
v8::CTypeInfo cargsaccess[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcaccess = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoaccess = v8::CFunctionInfo(rcaccess, 3, cargsaccess);
v8::CFunction pFaccess = v8::CFunction((const void*)&accessFast, &infoaccess);

int32_t openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
v8::CTypeInfo cargsopen[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcopen = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoopen = v8::CFunctionInfo(rcopen, 4, cargsopen);
v8::CFunction pFopen = v8::CFunction((const void*)&openFast, &infoopen);

int32_t unlinkFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsunlink[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcunlink = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infounlink = v8::CFunctionInfo(rcunlink, 2, cargsunlink);
v8::CFunction pFunlink = v8::CFunction((const void*)&unlinkFast, &infounlink);

int32_t openatFast(void* p, int32_t p0, struct FastOneByteString* const p1, int32_t p2);
v8::CTypeInfo cargsopenat[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcopenat = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoopenat = v8::CFunctionInfo(rcopenat, 4, cargsopenat);
v8::CFunction pFopenat = v8::CFunction((const void*)&openatFast, &infoopenat);

void readdirFast(void* p, void* p0, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsreaddir[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcreaddir = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo inforeaddir = v8::CFunctionInfo(rcreaddir, 3, cargsreaddir);
v8::CFunction pFreaddir = v8::CFunction((const void*)&readdirFast, &inforeaddir);

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, uint32_t p2);
v8::CTypeInfo cargsreadlink[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcreadlink = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo inforeadlink = v8::CFunctionInfo(rcreadlink, 4, cargsreadlink);
v8::CFunction pFreadlink = v8::CFunction((const void*)&readlinkFast, &inforeadlink);

void opendirFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsopendir[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcopendir = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infoopendir = v8::CFunctionInfo(rcopendir, 3, cargsopendir);
v8::CFunction pFopendir = v8::CFunction((const void*)&opendirFast, &infoopendir);

int32_t fstatatFast(void* p, int32_t p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p2, int32_t p3);
v8::CTypeInfo cargsfstatat[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcfstatat = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infofstatat = v8::CFunctionInfo(rcfstatat, 5, cargsfstatat);
v8::CFunction pFfstatat = v8::CFunction((const void*)&fstatatFast, &infofstatat);

int32_t mkdirFast(void* p, struct FastOneByteString* const p0, uint32_t p1);
v8::CTypeInfo cargsmkdir[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcmkdir = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomkdir = v8::CFunctionInfo(rcmkdir, 3, cargsmkdir);
v8::CFunction pFmkdir = v8::CFunction((const void*)&mkdirFast, &infomkdir);

int32_t rmdirFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsrmdir[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcrmdir = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo informdir = v8::CFunctionInfo(rcrmdir, 2, cargsrmdir);
v8::CFunction pFrmdir = v8::CFunction((const void*)&rmdirFast, &informdir);

int32_t closedirFast(void* p, void* p0);
v8::CTypeInfo cargsclosedir[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcclosedir = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoclosedir = v8::CFunctionInfo(rcclosedir, 2, cargsclosedir);
v8::CFunction pFclosedir = v8::CFunction((const void*)&closedirFast, &infoclosedir);

int32_t chdirFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargschdir[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcchdir = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infochdir = v8::CFunctionInfo(rcchdir, 2, cargschdir);
v8::CFunction pFchdir = v8::CFunction((const void*)&chdirFast, &infochdir);

int32_t fchdirFast(void* p, int32_t p0);
v8::CTypeInfo cargsfchdir[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcfchdir = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infofchdir = v8::CFunctionInfo(rcfchdir, 2, cargsfchdir);
v8::CFunction pFfchdir = v8::CFunction((const void*)&fchdirFast, &infofchdir);

int32_t mprotectFast(void* p, void* p0, uint32_t p1, int32_t p2);
v8::CTypeInfo cargsmprotect[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcmprotect = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomprotect = v8::CFunctionInfo(rcmprotect, 4, cargsmprotect);
v8::CFunction pFmprotect = v8::CFunction((const void*)&mprotectFast, &infomprotect);

void memcpyFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmemcpy[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmemcpy = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomemcpy = v8::CFunctionInfo(rcmemcpy, 5, cargsmemcpy);
v8::CFunction pFmemcpy = v8::CFunction((const void*)&memcpyFast, &infomemcpy);

void memsetFast(void* p, void* p0, int32_t p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmemset[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmemset = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomemset = v8::CFunctionInfo(rcmemset, 5, cargsmemset);
v8::CFunction pFmemset = v8::CFunction((const void*)&memsetFast, &infomemset);

void memmoveFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmemmove[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmemmove = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomemmove = v8::CFunctionInfo(rcmemmove, 5, cargsmemmove);
v8::CFunction pFmemmove = v8::CFunction((const void*)&memmoveFast, &infomemmove);

int32_t shm_openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
v8::CTypeInfo cargsshm_open[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcshm_open = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoshm_open = v8::CFunctionInfo(rcshm_open, 4, cargsshm_open);
v8::CFunction pFshm_open = v8::CFunction((const void*)&shm_openFast, &infoshm_open);

int32_t shm_unlinkFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsshm_unlink[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcshm_unlink = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoshm_unlink = v8::CFunctionInfo(rcshm_unlink, 2, cargsshm_unlink);
v8::CFunction pFshm_unlink = v8::CFunction((const void*)&shm_unlinkFast, &infoshm_unlink);

void mmapFast(void* p, void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmmap[8] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmmap = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infommap = v8::CFunctionInfo(rcmmap, 8, cargsmmap);
v8::CFunction pFmmap = v8::CFunction((const void*)&mmapFast, &infommap);

int32_t munmapFast(void* p, void* p0, uint32_t p1);
v8::CTypeInfo cargsmunmap[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcmunmap = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomunmap = v8::CFunctionInfo(rcmunmap, 3, cargsmunmap);
v8::CFunction pFmunmap = v8::CFunction((const void*)&munmapFast, &infomunmap);

int32_t msyncFast(void* p, void* p0, uint32_t p1, int32_t p2);
v8::CTypeInfo cargsmsync[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcmsync = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomsync = v8::CFunctionInfo(rcmsync, 4, cargsmsync);
v8::CFunction pFmsync = v8::CFunction((const void*)&msyncFast, &infomsync);

void mallocFast(void* p, uint32_t p0, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmalloc[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmalloc = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomalloc = v8::CFunctionInfo(rcmalloc, 3, cargsmalloc);
v8::CFunction pFmalloc = v8::CFunction((const void*)&mallocFast, &infomalloc);

void callocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargscalloc[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rccalloc = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infocalloc = v8::CFunctionInfo(rccalloc, 4, cargscalloc);
v8::CFunction pFcalloc = v8::CFunction((const void*)&callocFast, &infocalloc);

void reallocFast(void* p, void* p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsrealloc[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcrealloc = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo inforealloc = v8::CFunctionInfo(rcrealloc, 4, cargsrealloc);
v8::CFunction pFrealloc = v8::CFunction((const void*)&reallocFast, &inforealloc);

void aligned_allocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsaligned_alloc[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcaligned_alloc = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infoaligned_alloc = v8::CFunctionInfo(rcaligned_alloc, 4, cargsaligned_alloc);
v8::CFunction pFaligned_alloc = v8::CFunction((const void*)&aligned_allocFast, &infoaligned_alloc);

void freeFast(void* p, void* p0);
v8::CTypeInfo cargsfree[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcfree = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infofree = v8::CFunctionInfo(rcfree, 2, cargsfree);
v8::CFunction pFfree = v8::CFunction((const void*)&freeFast, &infofree);

void fastcallFast(void* p, void* p0);
v8::CTypeInfo cargsfastcall[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcfastcall = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infofastcall = v8::CFunctionInfo(rcfastcall, 2, cargsfastcall);
v8::CFunction pFfastcall = v8::CFunction((const void*)&fastcallFast, &infofastcall);

void getenvFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsgetenv[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcgetenv = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogetenv = v8::CFunctionInfo(rcgetenv, 3, cargsgetenv);
v8::CFunction pFgetenv = v8::CFunction((const void*)&getenvFast, &infogetenv);

int32_t setenvFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1, int32_t p2);
v8::CTypeInfo cargssetenv[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcsetenv = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infosetenv = v8::CFunctionInfo(rcsetenv, 4, cargssetenv);
v8::CFunction pFsetenv = v8::CFunction((const void*)&setenvFast, &infosetenv);

int32_t unsetenvFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsunsetenv[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcunsetenv = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infounsetenv = v8::CFunctionInfo(rcunsetenv, 2, cargsunsetenv);
v8::CFunction pFunsetenv = v8::CFunction((const void*)&unsetenvFast, &infounsetenv);

void sleepFast(void* p, int32_t p0);
v8::CTypeInfo cargssleep[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcsleep = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infosleep = v8::CFunctionInfo(rcsleep, 2, cargssleep);
v8::CFunction pFsleep = v8::CFunction((const void*)&sleepFast, &infosleep);

int32_t usleepFast(void* p, uint32_t p0);
v8::CTypeInfo cargsusleep[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcusleep = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infousleep = v8::CFunctionInfo(rcusleep, 2, cargsusleep);
v8::CFunction pFusleep = v8::CFunction((const void*)&usleepFast, &infousleep);

int32_t dupFast(void* p, int32_t p0);
v8::CTypeInfo cargsdup[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcdup = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infodup = v8::CFunctionInfo(rcdup, 2, cargsdup);
v8::CFunction pFdup = v8::CFunction((const void*)&dupFast, &infodup);

int32_t dup2Fast(void* p, int32_t p0, int32_t p1);
v8::CTypeInfo cargsdup2[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcdup2 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infodup2 = v8::CFunctionInfo(rcdup2, 3, cargsdup2);
v8::CFunction pFdup2 = v8::CFunction((const void*)&dup2Fast, &infodup2);

void getcwdFast(void* p, void* p0, int32_t p1, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsgetcwd[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcgetcwd = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogetcwd = v8::CFunctionInfo(rcgetcwd, 4, cargsgetcwd);
v8::CFunction pFgetcwd = v8::CFunction((const void*)&getcwdFast, &infogetcwd);

int32_t getpidFast(void* p);
v8::CTypeInfo cargsgetpid[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcgetpid = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetpid = v8::CFunctionInfo(rcgetpid, 1, cargsgetpid);
v8::CFunction pFgetpid = v8::CFunction((const void*)&getpidFast, &infogetpid);

int32_t forkFast(void* p);
v8::CTypeInfo cargsfork[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcfork = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infofork = v8::CFunctionInfo(rcfork, 1, cargsfork);
v8::CFunction pFfork = v8::CFunction((const void*)&forkFast, &infofork);

int32_t killFast(void* p, int32_t p0, int32_t p1);
v8::CTypeInfo cargskill[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rckill = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infokill = v8::CFunctionInfo(rckill, 3, cargskill);
v8::CFunction pFkill = v8::CFunction((const void*)&killFast, &infokill);

int32_t waitpidFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2);
v8::CTypeInfo cargswaitpid[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcwaitpid = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infowaitpid = v8::CFunctionInfo(rcwaitpid, 4, cargswaitpid);
v8::CFunction pFwaitpid = v8::CFunction((const void*)&waitpidFast, &infowaitpid);

int32_t execvpFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsexecvp[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcexecvp = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoexecvp = v8::CFunctionInfo(rcexecvp, 3, cargsexecvp);
v8::CFunction pFexecvp = v8::CFunction((const void*)&execvpFast, &infoexecvp);

int32_t execveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargsexecve[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcexecve = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoexecve = v8::CFunctionInfo(rcexecve, 4, cargsexecve);
v8::CFunction pFexecve = v8::CFunction((const void*)&execveFast, &infoexecve);

int32_t isattyFast(void* p, int32_t p0);
v8::CTypeInfo cargsisatty[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcisatty = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoisatty = v8::CFunctionInfo(rcisatty, 2, cargsisatty);
v8::CFunction pFisatty = v8::CFunction((const void*)&isattyFast, &infoisatty);

int32_t tcgetattrFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargstcgetattr[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rctcgetattr = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infotcgetattr = v8::CFunctionInfo(rctcgetattr, 3, cargstcgetattr);
v8::CFunction pFtcgetattr = v8::CFunction((const void*)&tcgetattrFast, &infotcgetattr);

int32_t tcsetattrFast(void* p, int32_t p0, int32_t p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargstcsetattr[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rctcsetattr = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infotcsetattr = v8::CFunctionInfo(rctcsetattr, 4, cargstcsetattr);
v8::CFunction pFtcsetattr = v8::CFunction((const void*)&tcsetattrFast, &infotcsetattr);

void exitFast(void* p, int32_t p0);
v8::CTypeInfo cargsexit[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcexit = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infoexit = v8::CFunctionInfo(rcexit, 2, cargsexit);
v8::CFunction pFexit = v8::CFunction((const void*)&exitFast, &infoexit);

uint32_t sysconfFast(void* p, int32_t p0);
v8::CTypeInfo cargssysconf[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcsysconf = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infosysconf = v8::CFunctionInfo(rcsysconf, 2, cargssysconf);
v8::CFunction pFsysconf = v8::CFunction((const void*)&sysconfFast, &infosysconf);

int32_t getrusageFast(void* p, int32_t p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsgetrusage[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcgetrusage = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetrusage = v8::CFunctionInfo(rcgetrusage, 3, cargsgetrusage);
v8::CFunction pFgetrusage = v8::CFunction((const void*)&getrusageFast, &infogetrusage);

uint32_t timesFast(void* p, struct FastApiTypedArray* const p0);
v8::CTypeInfo cargstimes[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rctimes = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infotimes = v8::CFunctionInfo(rctimes, 2, cargstimes);
v8::CFunction pFtimes = v8::CFunction((const void*)&timesFast, &infotimes);

void isolate_context_destroyFast(void* p, struct FastApiTypedArray* const p0);
v8::CTypeInfo cargsisolate_context_destroy[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcisolate_context_destroy = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infoisolate_context_destroy = v8::CFunctionInfo(rcisolate_context_destroy, 2, cargsisolate_context_destroy);
v8::CFunction pFisolate_context_destroy = v8::CFunction((const void*)&isolate_context_destroyFast, &infoisolate_context_destroy);

int32_t isolate_context_sizeFast(void* p);
v8::CTypeInfo cargsisolate_context_size[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcisolate_context_size = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoisolate_context_size = v8::CFunctionInfo(rcisolate_context_size, 1, cargsisolate_context_size);
v8::CFunction pFisolate_context_size = v8::CFunction((const void*)&isolate_context_sizeFast, &infoisolate_context_size);

void memmemFast(void* p, void* p0, uint32_t p1, void* p2, uint32_t p3, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargsmemmem[6] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rcmemmem = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infomemmem = v8::CFunctionInfo(rcmemmem, 6, cargsmemmem);
v8::CFunction pFmemmem = v8::CFunction((const void*)&memmemFast, &infomemmem);

uint32_t strnlenFast(void* p, void* p0, uint32_t p1);
v8::CTypeInfo cargsstrnlen[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcstrnlen = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infostrnlen = v8::CFunctionInfo(rcstrnlen, 3, cargsstrnlen);
v8::CFunction pFstrnlen = v8::CFunction((const void*)&strnlenFast, &infostrnlen);

uint32_t strnlen_strFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsstrnlen_str[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcstrnlen_str = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infostrnlen_str = v8::CFunctionInfo(rcstrnlen_str, 2, cargsstrnlen_str);
v8::CFunction pFstrnlen_str = v8::CFunction((const void*)&strnlen_strFast, &infostrnlen_str);

void syncFast(void* p);
v8::CTypeInfo cargssync[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcsync = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infosync = v8::CFunctionInfo(rcsync, 1, cargssync);
v8::CFunction pFsync = v8::CFunction((const void*)&syncFast, &infosync);

#ifdef __linux__

int32_t posix_fadviseFast(void* p, int32_t p0, uint32_t p1, uint32_t p2, int32_t p3);
v8::CTypeInfo cargsposix_fadvise[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcposix_fadvise = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoposix_fadvise = v8::CFunctionInfo(rcposix_fadvise, 5, cargsposix_fadvise);
v8::CFunction pFposix_fadvise = v8::CFunction((const void*)&posix_fadviseFast, &infoposix_fadvise);

int32_t ioctlFast(void* p, int32_t p0, uint32_t p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargsioctl[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcioctl = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoioctl = v8::CFunctionInfo(rcioctl, 4, cargsioctl);
v8::CFunction pFioctl = v8::CFunction((const void*)&ioctlFast, &infoioctl);

int32_t ioctl2Fast(void* p, int32_t p0, uint32_t p1, int32_t p2);
v8::CTypeInfo cargsioctl2[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcioctl2 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoioctl2 = v8::CFunctionInfo(rcioctl2, 4, cargsioctl2);
v8::CFunction pFioctl2 = v8::CFunction((const void*)&ioctl2Fast, &infoioctl2);

int32_t ioctl3Fast(void* p, int32_t p0, uint32_t p1, void* p2);
v8::CTypeInfo cargsioctl3[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcioctl3 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoioctl3 = v8::CFunctionInfo(rcioctl3, 4, cargsioctl3);
v8::CFunction pFioctl3 = v8::CFunction((const void*)&ioctl3Fast, &infoioctl3);

int32_t rebootFast(void* p, int32_t p0);
v8::CTypeInfo cargsreboot[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcreboot = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo inforeboot = v8::CFunctionInfo(rcreboot, 2, cargsreboot);
v8::CFunction pFreboot = v8::CFunction((const void*)&rebootFast, &inforeboot);

uint32_t getdentsFast(void* p, int32_t p0, void* p1, uint32_t p2);
v8::CTypeInfo cargsgetdents[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcgetdents = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infogetdents = v8::CFunctionInfo(rcgetdents, 4, cargsgetdents);
v8::CFunction pFgetdents = v8::CFunction((const void*)&getdentsFast, &infogetdents);

int32_t getaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2);
v8::CTypeInfo cargsgetaffinity[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcgetaffinity = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetaffinity = v8::CFunctionInfo(rcgetaffinity, 4, cargsgetaffinity);
v8::CFunction pFgetaffinity = v8::CFunction((const void*)&getaffinityFast, &infogetaffinity);

uint32_t copy_file_rangeFast(void* p, int32_t p0, void* p1, int32_t p2, void* p3, uint32_t p4, uint32_t p5);
v8::CTypeInfo cargscopy_file_range[7] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rccopy_file_range = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infocopy_file_range = v8::CFunctionInfo(rccopy_file_range, 7, cargscopy_file_range);
v8::CFunction pFcopy_file_range = v8::CFunction((const void*)&copy_file_rangeFast, &infocopy_file_range);

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1);
v8::CTypeInfo cargsmemfd_create[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcmemfd_create = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomemfd_create = v8::CFunctionInfo(rcmemfd_create, 3, cargsmemfd_create);
v8::CFunction pFmemfd_create = v8::CFunction((const void*)&memfd_createFast, &infomemfd_create);

int32_t setaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2);
v8::CTypeInfo cargssetaffinity[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcsetaffinity = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infosetaffinity = v8::CFunctionInfo(rcsetaffinity, 4, cargssetaffinity);
v8::CFunction pFsetaffinity = v8::CFunction((const void*)&setaffinityFast, &infosetaffinity);

int32_t vforkFast(void* p);
v8::CTypeInfo cargsvfork[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcvfork = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infovfork = v8::CFunctionInfo(rcvfork, 1, cargsvfork);
v8::CFunction pFvfork = v8::CFunction((const void*)&vforkFast, &infovfork);

int32_t vexecveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargsvexecve[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcvexecve = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infovexecve = v8::CFunctionInfo(rcvexecve, 4, cargsvexecve);
v8::CFunction pFvexecve = v8::CFunction((const void*)&vexecveFast, &infovexecve);

int32_t vfexecveFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargsvfexecve[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcvfexecve = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infovfexecve = v8::CFunctionInfo(rcvfexecve, 4, cargsvfexecve);
v8::CFunction pFvfexecve = v8::CFunction((const void*)&vfexecveFast, &infovfexecve);

int32_t getpagesizeFast(void* p);
v8::CTypeInfo cargsgetpagesize[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rcgetpagesize = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infogetpagesize = v8::CFunctionInfo(rcgetpagesize, 1, cargsgetpagesize);
v8::CFunction pFgetpagesize = v8::CFunction((const void*)&getpagesizeFast, &infogetpagesize);

int32_t madviseFast(void* p, void* p0, uint32_t p1, int32_t p2);
v8::CTypeInfo cargsmadvise[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcmadvise = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infomadvise = v8::CFunctionInfo(rcmadvise, 4, cargsmadvise);
v8::CFunction pFmadvise = v8::CFunction((const void*)&madviseFast, &infomadvise);

#endif
#ifdef __MACH__

#endif

void dlopenSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = dlopen(*v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void dlopenFast(void* p, struct FastOneByteString* const p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  void* r = dlopen(v0->data, v1);
  ((void**)p_ret->data)[0] = r;

}
void dlsymSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  String::Utf8Value v1(isolate, args[1]);
  void* rc = dlsym(v0, *v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void dlsymFast(void* p, void* p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  struct FastOneByteString* const v1 = p1;
  void* r = dlsym(v0, v1->data);
  ((void**)p_ret->data)[0] = r;

}
void dlcloseSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = dlclose(v0);
  args.GetReturnValue().Set(rc);
}

int32_t dlcloseFast(void* p, void* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  return dlclose(v0);
}
void readSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void* v1 = reinterpret_cast<void*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = read(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t readFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1->data);
  int32_t v2 = p2;
  return read(v0, v1, v2);
}
void read2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = read(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t read2Fast(void* p, int32_t p0, void* p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1);
  int32_t v2 = p2;
  return read(v0, v1, v2);
}
void writeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void* v1 = reinterpret_cast<void*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = write(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t writeFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1->data);
  int32_t v2 = p2;
  return write(v0, v1, v2);
}
void write_stringSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  String::Utf8Value v1(isolate, args[1]);
  int32_t v2 = v1.length();
  int32_t rc = write(v0, *v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t write_stringFast(void* p, int32_t p0, struct FastOneByteString* const p1) {
  int32_t v0 = p0;
  struct FastOneByteString* const v1 = p1;
  int32_t v2 = p1->length;
  return write(v0, v1->data, v2);
}
void putcharSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = putchar(v0);
  args.GetReturnValue().Set(rc);
}

int32_t putcharFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return putchar(v0);
}
void closeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = close(v0);
  args.GetReturnValue().Set(rc);
}

int32_t closeFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return close(v0);
}
void preadSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void* v1 = reinterpret_cast<void*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = pread(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t preadFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2, uint32_t p3) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1->data);
  int32_t v2 = p2;
  uint32_t v3 = p3;
  return pread(v0, v1, v2, v3);
}
void lseekSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = lseek(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t lseekFast(void* p, int32_t p0, uint32_t p1, int32_t p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return lseek(v0, v1, v2);
}
void fstatSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct stat * v1 = reinterpret_cast<struct stat *>(ptr1);
  int32_t rc = fstat(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t fstatFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct stat * v1 = reinterpret_cast<struct stat *>(p1->data);
  return fstat(v0, v1);
}
void fcntlSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = fcntl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t fcntlFast(void* p, int32_t p0, int32_t p1, int32_t p2) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return fcntl(v0, v1, v2);
}
void ftruncateSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = ftruncate(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t ftruncateFast(void* p, int32_t p0, uint32_t p1) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  return ftruncate(v0, v1);
}
void mknodSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = mknod(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t mknodFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return mknod(v0->data, v1, v2);
}
void statSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct stat * v1 = reinterpret_cast<struct stat *>(ptr1);
  int32_t rc = stat(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t statFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct stat * v1 = reinterpret_cast<struct stat *>(p1->data);
  return stat(v0->data, v1);
}
void lstatSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct stat * v1 = reinterpret_cast<struct stat *>(ptr1);
  int32_t rc = lstat(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t lstatFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct stat * v1 = reinterpret_cast<struct stat *>(p1->data);
  return lstat(v0->data, v1);
}
void renameSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  String::Utf8Value v1(isolate, args[1]);
  int32_t rc = rename(*v0, *v1);
  args.GetReturnValue().Set(rc);
}

int32_t renameFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct FastOneByteString* const v1 = p1;
  return rename(v0->data, v1->data);
}
void accessSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = access(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t accessFast(void* p, struct FastOneByteString* const p0, int32_t p1) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  return access(v0->data, v1);
}
void openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = open(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return open(v0->data, v1, v2);
}
void unlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = unlink(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t unlinkFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return unlink(v0->data);
}
void openatSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  String::Utf8Value v1(isolate, args[1]);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = openat(v0, *v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t openatFast(void* p, int32_t p0, struct FastOneByteString* const p1, int32_t p2) {
  int32_t v0 = p0;
  struct FastOneByteString* const v1 = p1;
  int32_t v2 = p2;
  return openat(v0, v1->data, v2);
}
void readdirSlow(const FunctionCallbackInfo<Value> &args) {
  DIR* v0 = reinterpret_cast<DIR*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  dirent* rc = readdir(v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((dirent**)ab->Data())[0] = rc;
}

void readdirFast(void* p, void* p0, struct FastApiTypedArray* const p_ret) {
  DIR* v0 = reinterpret_cast<DIR*>(p0);
  dirent* r = readdir(v0);
  ((dirent**)p_ret->data)[0] = r;

}
void readlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* v1 = reinterpret_cast<char*>(ptr1);
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = readlink(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t readlinkFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, uint32_t p2) {
  struct FastOneByteString* const v0 = p0;
  char* v1 = reinterpret_cast<char*>(p1->data);
  uint32_t v2 = p2;
  return readlink(v0->data, v1, v2);
}
void opendirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  DIR* rc = opendir(*v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((DIR**)ab->Data())[0] = rc;
}

void opendirFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  DIR* r = opendir(v0->data);
  ((DIR**)p_ret->data)[0] = r;

}
void fstatatSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  String::Utf8Value v1(isolate, args[1]);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  struct stat * v2 = reinterpret_cast<struct stat *>(ptr2);
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = fstatat(v0, *v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t fstatatFast(void* p, int32_t p0, struct FastOneByteString* const p1, struct FastApiTypedArray* const p2, int32_t p3) {
  int32_t v0 = p0;
  struct FastOneByteString* const v1 = p1;
  struct stat * v2 = reinterpret_cast<struct stat *>(p2->data);
  int32_t v3 = p3;
  return fstatat(v0, v1->data, v2, v3);
}
void mkdirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = mkdir(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t mkdirFast(void* p, struct FastOneByteString* const p0, uint32_t p1) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p1;
  return mkdir(v0->data, v1);
}
void rmdirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = rmdir(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t rmdirFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return rmdir(v0->data);
}
void closedirSlow(const FunctionCallbackInfo<Value> &args) {
  DIR* v0 = reinterpret_cast<DIR*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = closedir(v0);
  args.GetReturnValue().Set(rc);
}

int32_t closedirFast(void* p, void* p0) {
  DIR* v0 = reinterpret_cast<DIR*>(p0);
  return closedir(v0);
}
void chdirSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = chdir(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t chdirFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return chdir(v0->data);
}
void fchdirSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = fchdir(v0);
  args.GetReturnValue().Set(rc);
}

int32_t fchdirFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return fchdir(v0);
}
void mprotectSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = mprotect(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t mprotectFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return mprotect(v0, v1, v2);
}
void memcpySlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memcpy(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memcpyFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memcpy(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void memsetSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memset(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memsetFast(void* p, void* p0, int32_t p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  int32_t v1 = p1;
  uint32_t v2 = p2;
  void* r = memset(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void memmoveSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memmove(v0, v1, v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memmoveFast(void* p, void* p0, void* p1, uint32_t p2, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memmove(v0, v1, v2);
  ((void**)p_ret->data)[0] = r;

}
void shm_openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = shm_open(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t shm_openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return shm_open(v0->data, v1, v2);
}
void shm_unlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = shm_unlink(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t shm_unlinkFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return shm_unlink(v0->data);
}
void mmapSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t v4 = Local<Integer>::Cast(args[4])->Value();
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  void* rc = mmap(v0, v1, v2, v3, v4, v5);
  Local<ArrayBuffer> ab = args[6].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void mmapFast(void* p, void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, uint32_t p5, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  int32_t v3 = p3;
  int32_t v4 = p4;
  uint32_t v5 = p5;
  void* r = mmap(v0, v1, v2, v3, v4, v5);
  ((void**)p_ret->data)[0] = r;

}
void munmapSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = munmap(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t munmapFast(void* p, void* p0, uint32_t p1) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  return munmap(v0, v1);
}
void msyncSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = msync(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t msyncFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return msync(v0, v1, v2);
}
void mallocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* rc = malloc(v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void mallocFast(void* p, uint32_t p0, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  void* r = malloc(v0);
  ((void**)p_ret->data)[0] = r;

}
void callocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = calloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void callocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = calloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void reallocSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = realloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void reallocFast(void* p, void* p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  void* r = realloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void aligned_allocSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = aligned_alloc(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void aligned_allocFast(void* p, uint32_t p0, uint32_t p1, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = aligned_alloc(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  free(v0);
}

void freeFast(void* p, void* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  free(v0);
}
void fastcallSlow(const FunctionCallbackInfo<Value> &args) {
  struct fastcall* v0 = reinterpret_cast<struct fastcall*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_fastcall(v0);
}

void fastcallFast(void* p, void* p0) {
  struct fastcall* v0 = reinterpret_cast<struct fastcall*>(p0);
  lo_fastcall(v0);
}
void getenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* rc = getenv(*v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((char**)ab->Data())[0] = rc;
}

void getenvFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p_ret) {
  struct FastOneByteString* const v0 = p0;
  char* r = getenv(v0->data);
  ((char**)p_ret->data)[0] = r;

}
void setenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  String::Utf8Value v1(isolate, args[1]);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = setenv(*v0, *v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t setenvFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  struct FastOneByteString* const v1 = p1;
  int32_t v2 = p2;
  return setenv(v0->data, v1->data, v2);
}
void unsetenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = unsetenv(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t unsetenvFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return unsetenv(v0->data);
}
void sleepSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  sleep(v0);
}

void sleepFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  sleep(v0);
}
void usleepSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = usleep(v0);
  args.GetReturnValue().Set(rc);
}

int32_t usleepFast(void* p, uint32_t p0) {
  uint32_t v0 = p0;
  return usleep(v0);
}
void dupSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = dup(v0);
  args.GetReturnValue().Set(rc);
}

int32_t dupFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return dup(v0);
}
void dup2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = dup2(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t dup2Fast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return dup2(v0, v1);
}
void getcwdSlow(const FunctionCallbackInfo<Value> &args) {
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = getcwd(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void getcwdFast(void* p, void* p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  char* v0 = reinterpret_cast<char*>(p0);
  int32_t v1 = p1;
  void* r = getcwd(v0, v1);
  ((void**)p_ret->data)[0] = r;

}
void getpidSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getpid();
  args.GetReturnValue().Set(rc);
}

int32_t getpidFast(void* p) {

  return getpid();
}
void forkSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = fork();
  args.GetReturnValue().Set(rc);
}

int32_t forkFast(void* p) {

  return fork();
}
void killSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = kill(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t killFast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return kill(v0, v1);
}
void waitpidSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  int* v1 = reinterpret_cast<int*>(ptr1);
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = waitpid(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t waitpidFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, int32_t p2) {
  int32_t v0 = p0;
  int* v1 = reinterpret_cast<int*>(p1->data);
  int32_t v2 = p2;
  return waitpid(v0, v1, v2);
}
void execvpSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  int32_t rc = execvp(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t execvpFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  return execvp(v0->data, v1);
}
void execveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  char* const* v2 = reinterpret_cast<char* const*>(ptr2);
  int32_t rc = execve(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t execveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  char* const* v2 = reinterpret_cast<char* const*>(p2->data);
  return execve(v0->data, v1, v2);
}
void isattySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = isatty(v0);
  args.GetReturnValue().Set(rc);
}

int32_t isattyFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return isatty(v0);
}
void tcgetattrSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct termios * v1 = reinterpret_cast<struct termios *>(ptr1);
  int32_t rc = tcgetattr(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t tcgetattrFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct termios * v1 = reinterpret_cast<struct termios *>(p1->data);
  return tcgetattr(v0, v1);
}
void tcsetattrSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  struct termios * v2 = reinterpret_cast<struct termios *>(ptr2);
  int32_t rc = tcsetattr(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t tcsetattrFast(void* p, int32_t p0, int32_t p1, struct FastApiTypedArray* const p2) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  struct termios * v2 = reinterpret_cast<struct termios *>(p2->data);
  return tcsetattr(v0, v1, v2);
}
void exitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  exit(v0);
}

void exitFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  exit(v0);
}
void sysconfSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t rc = sysconf(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t sysconfFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return sysconf(v0);
}
void getrusageSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  struct rusage* v1 = reinterpret_cast<struct rusage*>(ptr1);
  int32_t rc = getrusage(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t getrusageFast(void* p, int32_t p0, struct FastApiTypedArray* const p1) {
  int32_t v0 = p0;
  struct rusage* v1 = reinterpret_cast<struct rusage*>(p1->data);
  return getrusage(v0, v1);
}
void timesSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  struct tms* v0 = reinterpret_cast<struct tms*>(ptr0);
  uint32_t rc = times(v0);
  args.GetReturnValue().Set(rc);
}

uint32_t timesFast(void* p, struct FastApiTypedArray* const p0) {
  struct tms* v0 = reinterpret_cast<struct tms*>(p0->data);
  return times(v0);
}
void isolate_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  char** v1 = reinterpret_cast<char**>(ptr1);
  String::Utf8Value v2(isolate, args[2]);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  String::Utf8Value v4(isolate, args[4]);
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  Local<Uint8Array> u86 = args[6].As<Uint8Array>();
  uint8_t* ptr6 = (uint8_t*)u86->Buffer()->Data() + u86->ByteOffset();
  char* v6 = reinterpret_cast<char*>(ptr6);
  int32_t v7 = Local<Integer>::Cast(args[7])->Value();
  int32_t v8 = Local<Integer>::Cast(args[8])->Value();
  uint64_t v9 = Local<Integer>::Cast(args[9])->Value();
  String::Utf8Value v10(isolate, args[10]);
  String::Utf8Value v11(isolate, args[11]);
  int32_t v12 = Local<Integer>::Cast(args[12])->Value();
  int32_t v13 = Local<Integer>::Cast(args[13])->Value();
  void* v14 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[14])->Value());
  int32_t rc = lo_create_isolate(v0, v1, *v2, v3, *v4, v5, v6, v7, v8, v9, *v10, *v11, v12, v13, v14);
  args.GetReturnValue().Set(rc);
}

void isolate_context_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  char** v1 = reinterpret_cast<char**>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  String::Utf8Value v2(isolate, args[2]);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  String::Utf8Value v4(isolate, args[4]);
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  char* v6 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[6])->Value());
  int32_t v7 = Local<Integer>::Cast(args[7])->Value();
  int32_t v8 = Local<Integer>::Cast(args[8])->Value();
  uint64_t v9 = Local<Integer>::Cast(args[9])->Value();
  String::Utf8Value v10(isolate, args[10]);
  String::Utf8Value v11(isolate, args[11]);
  int32_t v12 = Local<Integer>::Cast(args[12])->Value();
  int32_t v13 = Local<Integer>::Cast(args[13])->Value();
  void* v14 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[14])->Value());
  Local<Uint8Array> u815 = args[15].As<Uint8Array>();
  uint8_t* ptr15 = (uint8_t*)u815->Buffer()->Data() + u815->ByteOffset();
  struct isolate_context* v15 = reinterpret_cast<struct isolate_context*>(ptr15);
  lo_create_isolate_context(v0, v1, *v2, v3, *v4, v5, v6, v7, v8, v9, *v10, *v11, v12, v13, v14, v15);
}

void isolate_context_destroySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  struct isolate_context* v0 = reinterpret_cast<struct isolate_context*>(ptr0);
  lo_destroy_isolate_context(v0);
}

void isolate_context_destroyFast(void* p, struct FastApiTypedArray* const p0) {
  struct isolate_context* v0 = reinterpret_cast<struct isolate_context*>(p0->data);
  lo_destroy_isolate_context(v0);
}
void isolate_context_sizeSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = lo_context_size();
  args.GetReturnValue().Set(rc);
}

int32_t isolate_context_sizeFast(void* p) {

  return lo_context_size();
}
void isolate_startSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  void* v0 = reinterpret_cast<void*>(ptr0);
  lo_start_isolate(v0);
}

void callbackSlow(const FunctionCallbackInfo<Value> &args) {
  exec_info* v0 = reinterpret_cast<exec_info*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_callback(v0);
}

void memmemSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* v2 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  void* rc = memmem(v0, v1, v2, v3);
  Local<ArrayBuffer> ab = args[4].As<Uint32Array>()->Buffer();
  ((void**)ab->Data())[0] = rc;
}

void memmemFast(void* p, void* p0, uint32_t p1, void* p2, uint32_t p3, struct FastApiTypedArray* const p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  void* v2 = reinterpret_cast<void*>(p2);
  uint32_t v3 = p3;
  void* r = memmem(v0, v1, v2, v3);
  ((void**)p_ret->data)[0] = r;

}
void strnlenSlow(const FunctionCallbackInfo<Value> &args) {
  const char* v0 = reinterpret_cast<const char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t rc = strnlen(v0, v1);
  args.GetReturnValue().Set(rc);
}

uint32_t strnlenFast(void* p, void* p0, uint32_t p1) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  uint32_t v1 = p1;
  return strnlen(v0, v1);
}
void strnlen_strSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = v0.length();
  uint32_t rc = strnlen(*v0, v1);
  args.GetReturnValue().Set(rc);
}

uint32_t strnlen_strFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p0->length;
  return strnlen(v0->data, v1);
}
void syncSlow(const FunctionCallbackInfo<Value> &args) {

  sync();
}

void syncFast(void* p) {

  sync();
}
#ifdef __linux__

void posix_fadviseSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = posix_fadvise(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t posix_fadviseFast(void* p, int32_t p0, uint32_t p1, uint32_t p2, int32_t p3) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  uint32_t v2 = p2;
  int32_t v3 = p3;
  return posix_fadvise(v0, v1, v2, v3);
}
void ioctlSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  void* v2 = reinterpret_cast<void*>(ptr2);
  int32_t rc = ioctl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t ioctlFast(void* p, int32_t p0, uint32_t p1, struct FastApiTypedArray* const p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  void* v2 = reinterpret_cast<void*>(p2->data);
  return ioctl(v0, v1, v2);
}
void ioctl2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = ioctl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t ioctl2Fast(void* p, int32_t p0, uint32_t p1, int32_t p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return ioctl(v0, v1, v2);
}
void ioctl3Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* v2 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = ioctl(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t ioctl3Fast(void* p, int32_t p0, uint32_t p1, void* p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  void* v2 = reinterpret_cast<void*>(p2);
  return ioctl(v0, v1, v2);
}
void rebootSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = reboot(v0);
  args.GetReturnValue().Set(rc);
}

int32_t rebootFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return reboot(v0);
}
void getdentsSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = getdents64(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t getdentsFast(void* p, int32_t p0, void* p1, uint32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  return getdents64(v0, v1, v2);
}
void getaffinitySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = sched_getaffinity(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t getaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>(p2);
  return sched_getaffinity(v0, v1, v2);
}
void copy_file_rangeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  loff_t* v1 = reinterpret_cast<loff_t*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  loff_t* v3 = reinterpret_cast<loff_t*>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  uint32_t v4 = Local<Integer>::Cast(args[4])->Value();
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  uint32_t rc = copy_file_range(v0, v1, v2, v3, v4, v5);
  args.GetReturnValue().Set(rc);
}

uint32_t copy_file_rangeFast(void* p, int32_t p0, void* p1, int32_t p2, void* p3, uint32_t p4, uint32_t p5) {
  int32_t v0 = p0;
  loff_t* v1 = reinterpret_cast<loff_t*>(p1);
  int32_t v2 = p2;
  loff_t* v3 = reinterpret_cast<loff_t*>(p3);
  uint32_t v4 = p4;
  uint32_t v5 = p5;
  return copy_file_range(v0, v1, v2, v3, v4, v5);
}
void memfd_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = memfd_create(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t memfd_createFast(void* p, struct FastOneByteString* const p0, uint32_t p1) {
  struct FastOneByteString* const v0 = p0;
  uint32_t v1 = p1;
  return memfd_create(v0->data, v1);
}
void setaffinitySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = sched_setaffinity(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t setaffinityFast(void* p, int32_t p0, uint32_t p1, void* p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  cpu_set_t* v2 = reinterpret_cast<cpu_set_t*>(p2);
  return sched_setaffinity(v0, v1, v2);
}
void vforkSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = vfork();
  args.GetReturnValue().Set(rc);
}

int32_t vforkFast(void* p) {

  return vfork();
}
void vexecveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  char* const* v2 = reinterpret_cast<char* const*>(ptr2);
  int32_t rc = vexecve(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t vexecveFast(void* p, struct FastOneByteString* const p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  char* const* v2 = reinterpret_cast<char* const*>(p2->data);
  return vexecve(v0->data, v1, v2);
}
void vfexecveSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  char* const* v1 = reinterpret_cast<char* const*>(ptr1);
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  char* const* v2 = reinterpret_cast<char* const*>(ptr2);
  int32_t rc = vfexecve(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t vfexecveFast(void* p, int32_t p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2) {
  int32_t v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1->data);
  char* const* v2 = reinterpret_cast<char* const*>(p2->data);
  return vfexecve(v0, v1, v2);
}
void getpagesizeSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getpagesize();
  args.GetReturnValue().Set(rc);
}

int32_t getpagesizeFast(void* p) {

  return getpagesize();
}
void madviseSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = madvise(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t madviseFast(void* p, void* p0, uint32_t p1, int32_t p2) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return madvise(v0, v1, v2);
}
#endif
#ifdef __MACH__

#endif
void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "dlopen", &pFdlopen, dlopenSlow);
  SET_FAST_METHOD(isolate, module, "dlsym", &pFdlsym, dlsymSlow);
  SET_FAST_METHOD(isolate, module, "dlclose", &pFdlclose, dlcloseSlow);
  SET_FAST_METHOD(isolate, module, "read", &pFread, readSlow);
  SET_FAST_METHOD(isolate, module, "read2", &pFread2, read2Slow);
  SET_FAST_METHOD(isolate, module, "write", &pFwrite, writeSlow);
  SET_FAST_METHOD(isolate, module, "write_string", &pFwrite_string, write_stringSlow);
  SET_FAST_METHOD(isolate, module, "putchar", &pFputchar, putcharSlow);
  SET_FAST_METHOD(isolate, module, "close", &pFclose, closeSlow);
  SET_FAST_METHOD(isolate, module, "pread", &pFpread, preadSlow);
  SET_FAST_METHOD(isolate, module, "lseek", &pFlseek, lseekSlow);
  SET_FAST_METHOD(isolate, module, "fstat", &pFfstat, fstatSlow);
  SET_FAST_METHOD(isolate, module, "fcntl", &pFfcntl, fcntlSlow);
  SET_FAST_METHOD(isolate, module, "ftruncate", &pFftruncate, ftruncateSlow);
  SET_FAST_METHOD(isolate, module, "mknod", &pFmknod, mknodSlow);
  SET_FAST_METHOD(isolate, module, "stat", &pFstat, statSlow);
  SET_FAST_METHOD(isolate, module, "lstat", &pFlstat, lstatSlow);
  SET_FAST_METHOD(isolate, module, "rename", &pFrename, renameSlow);
  SET_FAST_METHOD(isolate, module, "access", &pFaccess, accessSlow);
  SET_FAST_METHOD(isolate, module, "open", &pFopen, openSlow);
  SET_FAST_METHOD(isolate, module, "unlink", &pFunlink, unlinkSlow);
  SET_FAST_METHOD(isolate, module, "openat", &pFopenat, openatSlow);
  SET_FAST_METHOD(isolate, module, "readdir", &pFreaddir, readdirSlow);
  SET_FAST_METHOD(isolate, module, "readlink", &pFreadlink, readlinkSlow);
  SET_FAST_METHOD(isolate, module, "opendir", &pFopendir, opendirSlow);
  SET_FAST_METHOD(isolate, module, "fstatat", &pFfstatat, fstatatSlow);
  SET_FAST_METHOD(isolate, module, "mkdir", &pFmkdir, mkdirSlow);
  SET_FAST_METHOD(isolate, module, "rmdir", &pFrmdir, rmdirSlow);
  SET_FAST_METHOD(isolate, module, "closedir", &pFclosedir, closedirSlow);
  SET_FAST_METHOD(isolate, module, "chdir", &pFchdir, chdirSlow);
  SET_FAST_METHOD(isolate, module, "fchdir", &pFfchdir, fchdirSlow);
  SET_FAST_METHOD(isolate, module, "mprotect", &pFmprotect, mprotectSlow);
  SET_FAST_METHOD(isolate, module, "memcpy", &pFmemcpy, memcpySlow);
  SET_FAST_METHOD(isolate, module, "memset", &pFmemset, memsetSlow);
  SET_FAST_METHOD(isolate, module, "memmove", &pFmemmove, memmoveSlow);
  SET_FAST_METHOD(isolate, module, "shm_open", &pFshm_open, shm_openSlow);
  SET_FAST_METHOD(isolate, module, "shm_unlink", &pFshm_unlink, shm_unlinkSlow);
  SET_FAST_METHOD(isolate, module, "mmap", &pFmmap, mmapSlow);
  SET_FAST_METHOD(isolate, module, "munmap", &pFmunmap, munmapSlow);
  SET_FAST_METHOD(isolate, module, "msync", &pFmsync, msyncSlow);
  SET_FAST_METHOD(isolate, module, "malloc", &pFmalloc, mallocSlow);
  SET_FAST_METHOD(isolate, module, "calloc", &pFcalloc, callocSlow);
  SET_FAST_METHOD(isolate, module, "realloc", &pFrealloc, reallocSlow);
  SET_FAST_METHOD(isolate, module, "aligned_alloc", &pFaligned_alloc, aligned_allocSlow);
  SET_FAST_METHOD(isolate, module, "free", &pFfree, freeSlow);
  SET_METHOD(isolate, module, "bind_fastcall", bind_fastcallSlow);
  SET_METHOD(isolate, module, "bind_slowcall", bind_slowcallSlow);
  SET_FAST_METHOD(isolate, module, "fastcall", &pFfastcall, fastcallSlow);
  SET_FAST_METHOD(isolate, module, "getenv", &pFgetenv, getenvSlow);
  SET_FAST_METHOD(isolate, module, "setenv", &pFsetenv, setenvSlow);
  SET_FAST_METHOD(isolate, module, "unsetenv", &pFunsetenv, unsetenvSlow);
  SET_FAST_METHOD(isolate, module, "sleep", &pFsleep, sleepSlow);
  SET_FAST_METHOD(isolate, module, "usleep", &pFusleep, usleepSlow);
  SET_FAST_METHOD(isolate, module, "dup", &pFdup, dupSlow);
  SET_FAST_METHOD(isolate, module, "dup2", &pFdup2, dup2Slow);
  SET_FAST_METHOD(isolate, module, "getcwd", &pFgetcwd, getcwdSlow);
  SET_FAST_METHOD(isolate, module, "getpid", &pFgetpid, getpidSlow);
  SET_FAST_METHOD(isolate, module, "fork", &pFfork, forkSlow);
  SET_FAST_METHOD(isolate, module, "kill", &pFkill, killSlow);
  SET_FAST_METHOD(isolate, module, "waitpid", &pFwaitpid, waitpidSlow);
  SET_FAST_METHOD(isolate, module, "execvp", &pFexecvp, execvpSlow);
  SET_FAST_METHOD(isolate, module, "execve", &pFexecve, execveSlow);
  SET_FAST_METHOD(isolate, module, "isatty", &pFisatty, isattySlow);
  SET_FAST_METHOD(isolate, module, "tcgetattr", &pFtcgetattr, tcgetattrSlow);
  SET_FAST_METHOD(isolate, module, "tcsetattr", &pFtcsetattr, tcsetattrSlow);
  SET_FAST_METHOD(isolate, module, "exit", &pFexit, exitSlow);
  SET_FAST_METHOD(isolate, module, "sysconf", &pFsysconf, sysconfSlow);
  SET_FAST_METHOD(isolate, module, "getrusage", &pFgetrusage, getrusageSlow);
  SET_FAST_METHOD(isolate, module, "times", &pFtimes, timesSlow);
  SET_METHOD(isolate, module, "isolate_create", isolate_createSlow);
  SET_METHOD(isolate, module, "isolate_context_create", isolate_context_createSlow);
  SET_FAST_METHOD(isolate, module, "isolate_context_destroy", &pFisolate_context_destroy, isolate_context_destroySlow);
  SET_FAST_METHOD(isolate, module, "isolate_context_size", &pFisolate_context_size, isolate_context_sizeSlow);
  SET_METHOD(isolate, module, "isolate_start", isolate_startSlow);
  SET_METHOD(isolate, module, "callback", callbackSlow);
  SET_FAST_METHOD(isolate, module, "memmem", &pFmemmem, memmemSlow);
  SET_FAST_METHOD(isolate, module, "strnlen", &pFstrnlen, strnlenSlow);
  SET_FAST_METHOD(isolate, module, "strnlen_str", &pFstrnlen_str, strnlen_strSlow);
  SET_FAST_METHOD(isolate, module, "sync", &pFsync, syncSlow);

#ifdef __linux__
  SET_FAST_METHOD(isolate, module, "posix_fadvise", &pFposix_fadvise, posix_fadviseSlow);
  SET_FAST_METHOD(isolate, module, "ioctl", &pFioctl, ioctlSlow);
  SET_FAST_METHOD(isolate, module, "ioctl2", &pFioctl2, ioctl2Slow);
  SET_FAST_METHOD(isolate, module, "ioctl3", &pFioctl3, ioctl3Slow);
  SET_FAST_METHOD(isolate, module, "reboot", &pFreboot, rebootSlow);
  SET_FAST_METHOD(isolate, module, "getdents", &pFgetdents, getdentsSlow);
  SET_FAST_METHOD(isolate, module, "getaffinity", &pFgetaffinity, getaffinitySlow);
  SET_FAST_METHOD(isolate, module, "copy_file_range", &pFcopy_file_range, copy_file_rangeSlow);
  SET_FAST_METHOD(isolate, module, "memfd_create", &pFmemfd_create, memfd_createSlow);
  SET_FAST_METHOD(isolate, module, "setaffinity", &pFsetaffinity, setaffinitySlow);
  SET_FAST_METHOD(isolate, module, "vfork", &pFvfork, vforkSlow);
  SET_FAST_METHOD(isolate, module, "vexecve", &pFvexecve, vexecveSlow);
  SET_FAST_METHOD(isolate, module, "vfexecve", &pFvfexecve, vfexecveSlow);
  SET_FAST_METHOD(isolate, module, "getpagesize", &pFgetpagesize, getpagesizeSlow);
  SET_FAST_METHOD(isolate, module, "madvise", &pFmadvise, madviseSlow);

#endif
#ifdef __MACH__

#endif
  SET_VALUE(isolate, module, "S_IFBLK", Integer::New(isolate, (int32_t)S_IFBLK));
  SET_VALUE(isolate, module, "S_IFCHR", Integer::New(isolate, (int32_t)S_IFCHR));
  SET_VALUE(isolate, module, "S_IFIFO", Integer::New(isolate, (int32_t)S_IFIFO));
  SET_VALUE(isolate, module, "S_IRUSR", Integer::New(isolate, (int32_t)S_IRUSR));
  SET_VALUE(isolate, module, "S_IWUSR", Integer::New(isolate, (int32_t)S_IWUSR));
  SET_VALUE(isolate, module, "S_IRGRP", Integer::New(isolate, (int32_t)S_IRGRP));
  SET_VALUE(isolate, module, "S_IWGRP", Integer::New(isolate, (int32_t)S_IWGRP));
  SET_VALUE(isolate, module, "S_IROTH", Integer::New(isolate, (int32_t)S_IROTH));
  SET_VALUE(isolate, module, "S_IWOTH", Integer::New(isolate, (int32_t)S_IWOTH));
  SET_VALUE(isolate, module, "O_RDONLY", Integer::New(isolate, (int32_t)O_RDONLY));
  SET_VALUE(isolate, module, "O_WRONLY", Integer::New(isolate, (int32_t)O_WRONLY));
  SET_VALUE(isolate, module, "O_CREAT", Integer::New(isolate, (int32_t)O_CREAT));
  SET_VALUE(isolate, module, "S_IRWXU", Integer::New(isolate, (int32_t)S_IRWXU));
  SET_VALUE(isolate, module, "S_IRWXG", Integer::New(isolate, (int32_t)S_IRWXG));
  SET_VALUE(isolate, module, "S_IXOTH", Integer::New(isolate, (int32_t)S_IXOTH));
  SET_VALUE(isolate, module, "O_TRUNC", Integer::New(isolate, (int32_t)O_TRUNC));
  SET_VALUE(isolate, module, "STDIN", Number::New(isolate, (int64_t)0));
  SET_VALUE(isolate, module, "STDOUT", Number::New(isolate, (int64_t)1));
  SET_VALUE(isolate, module, "STDERR", Number::New(isolate, (int64_t)2));
  SET_VALUE(isolate, module, "O_CLOEXEC", Integer::New(isolate, (int32_t)O_CLOEXEC));
  SET_VALUE(isolate, module, "RUSAGE_SELF", Integer::New(isolate, (int32_t)RUSAGE_SELF));
  SET_VALUE(isolate, module, "SEEK_SET", Integer::New(isolate, (int32_t)SEEK_SET));
  SET_VALUE(isolate, module, "SEEK_CUR", Integer::New(isolate, (int32_t)SEEK_CUR));
  SET_VALUE(isolate, module, "SEEK_END", Integer::New(isolate, (int32_t)SEEK_END));
  SET_VALUE(isolate, module, "S_IRWXO", Integer::New(isolate, (int32_t)S_IRWXO));
  SET_VALUE(isolate, module, "F_OK", Integer::New(isolate, (int32_t)F_OK));
  SET_VALUE(isolate, module, "S_IFMT", Integer::New(isolate, (int32_t)S_IFMT));
  SET_VALUE(isolate, module, "S_IFDIR", Integer::New(isolate, (int32_t)S_IFDIR));
  SET_VALUE(isolate, module, "S_IFREG", Integer::New(isolate, (int32_t)S_IFREG));
  SET_VALUE(isolate, module, "NAME_MAX", Integer::New(isolate, (uint32_t)NAME_MAX));
  SET_VALUE(isolate, module, "O_RDWR", Integer::New(isolate, (int32_t)O_RDWR));
  SET_VALUE(isolate, module, "O_SYNC", Integer::New(isolate, (int32_t)O_SYNC));
  SET_VALUE(isolate, module, "O_DIRECTORY", Integer::New(isolate, (int32_t)O_DIRECTORY));
  SET_VALUE(isolate, module, "F_SETFL", Integer::New(isolate, (int32_t)F_SETFL));
  SET_VALUE(isolate, module, "O_NONBLOCK", Integer::New(isolate, (int32_t)O_NONBLOCK));
  SET_VALUE(isolate, module, "EAGAIN", Integer::New(isolate, (int32_t)EAGAIN));
  SET_VALUE(isolate, module, "WNOHANG", Integer::New(isolate, (int32_t)WNOHANG));
  SET_VALUE(isolate, module, "SIGTERM", Integer::New(isolate, (int32_t)SIGTERM));
  SET_VALUE(isolate, module, "MAP_SHARED", Integer::New(isolate, (int32_t)MAP_SHARED));
  SET_VALUE(isolate, module, "MAP_ANONYMOUS", Integer::New(isolate, (int32_t)MAP_ANONYMOUS));
  SET_VALUE(isolate, module, "MAP_PRIVATE", Integer::New(isolate, (int32_t)MAP_PRIVATE));
  SET_VALUE(isolate, module, "MS_ASYNC", Integer::New(isolate, (int32_t)MS_ASYNC));
  SET_VALUE(isolate, module, "MS_SYNC", Integer::New(isolate, (int32_t)MS_SYNC));
  SET_VALUE(isolate, module, "MS_INVALIDATE", Integer::New(isolate, (int32_t)MS_INVALIDATE));
  SET_VALUE(isolate, module, "_SC_CLK_TCK", Integer::New(isolate, (int32_t)_SC_CLK_TCK));
  SET_VALUE(isolate, module, "F_GETFL", Integer::New(isolate, (int32_t)F_GETFL));
  SET_VALUE(isolate, module, "RTLD_NOW", Integer::New(isolate, (int32_t)RTLD_NOW));
  SET_VALUE(isolate, module, "RTLD_LAZY", Integer::New(isolate, (int32_t)RTLD_LAZY));
  SET_VALUE(isolate, module, "RTLD_GLOBAL", Integer::New(isolate, (int32_t)RTLD_GLOBAL));
  SET_VALUE(isolate, module, "RTLD_LOCAL", Integer::New(isolate, (int32_t)RTLD_LOCAL));
  SET_VALUE(isolate, module, "RTLD_NODELETE", Integer::New(isolate, (int32_t)RTLD_NODELETE));
  SET_VALUE(isolate, module, "RTLD_NOLOAD", Integer::New(isolate, (int32_t)RTLD_NOLOAD));
  SET_VALUE(isolate, module, "RTLD_DEFAULT", BigInt::New(isolate, (uint64_t)RTLD_DEFAULT));
  SET_VALUE(isolate, module, "RTLD_NEXT", BigInt::New(isolate, (uint64_t)RTLD_NEXT));
  SET_VALUE(isolate, module, "PROT_READ", Integer::New(isolate, (int32_t)PROT_READ));
  SET_VALUE(isolate, module, "PROT_WRITE", Integer::New(isolate, (int32_t)PROT_WRITE));
  SET_VALUE(isolate, module, "PROT_EXEC", Integer::New(isolate, (int32_t)PROT_EXEC));
  SET_VALUE(isolate, module, "_SC_PAGESIZE", Integer::New(isolate, (int32_t)_SC_PAGESIZE));
  SET_VALUE(isolate, module, "DT_BLK", Integer::New(isolate, (int32_t)DT_BLK));
  SET_VALUE(isolate, module, "DT_CHR", Integer::New(isolate, (int32_t)DT_CHR));
  SET_VALUE(isolate, module, "DT_DIR", Integer::New(isolate, (int32_t)DT_DIR));
  SET_VALUE(isolate, module, "DT_FIFO", Integer::New(isolate, (int32_t)DT_FIFO));
  SET_VALUE(isolate, module, "DT_LNK", Integer::New(isolate, (int32_t)DT_LNK));
  SET_VALUE(isolate, module, "DT_REG", Integer::New(isolate, (int32_t)DT_REG));
  SET_VALUE(isolate, module, "DT_SOCK", Integer::New(isolate, (int32_t)DT_SOCK));
  SET_VALUE(isolate, module, "DT_UNKNOWN", Integer::New(isolate, (int32_t)DT_UNKNOWN));

#ifdef __linux__
  SET_VALUE(isolate, module, "LINUX_REBOOT_CMD_HALT", Integer::New(isolate, (uint32_t)LINUX_REBOOT_CMD_HALT));
  SET_VALUE(isolate, module, "LINUX_REBOOT_CMD_POWER_OFF", Integer::New(isolate, (uint32_t)LINUX_REBOOT_CMD_POWER_OFF));
  SET_VALUE(isolate, module, "LINUX_REBOOT_CMD_RESTART", Integer::New(isolate, (uint32_t)LINUX_REBOOT_CMD_RESTART));
  SET_VALUE(isolate, module, "RB_POWER_OFF", Integer::New(isolate, (int32_t)RB_POWER_OFF));
  SET_VALUE(isolate, module, "EINTR", Integer::New(isolate, (int32_t)EINTR));
  SET_VALUE(isolate, module, "MFD_CLOEXEC", Integer::New(isolate, (int32_t)MFD_CLOEXEC));
  SET_VALUE(isolate, module, "MAP_HUGETLB", Integer::New(isolate, (int32_t)MAP_HUGETLB));
  SET_VALUE(isolate, module, "MAP_HUGE_SHIFT", Integer::New(isolate, (int32_t)MAP_HUGE_SHIFT));
  SET_VALUE(isolate, module, "MFD_HUGETLB", Integer::New(isolate, (int32_t)MFD_HUGETLB));
  SET_VALUE(isolate, module, "MADV_HUGEPAGE", Integer::New(isolate, (int32_t)MADV_HUGEPAGE));
  SET_VALUE(isolate, module, "MAP_FIXED", Integer::New(isolate, (int32_t)MAP_FIXED));
  SET_VALUE(isolate, module, "POSIX_FADV_SEQUENTIAL", Integer::New(isolate, (int32_t)POSIX_FADV_SEQUENTIAL));
  SET_VALUE(isolate, module, "POSIX_FADV_WILLNEED", Integer::New(isolate, (int32_t)POSIX_FADV_WILLNEED));
  SET_VALUE(isolate, module, "POSIX_FADV_RANDOM", Integer::New(isolate, (int32_t)POSIX_FADV_RANDOM));
  SET_VALUE(isolate, module, "POSIX_FADV_DONTNEED", Integer::New(isolate, (int32_t)POSIX_FADV_DONTNEED));

#endif
#ifdef __MACH__
  SET_VALUE(isolate, module, "RTLD_FIRST", Integer::New(isolate, (int32_t)RTLD_FIRST));
  SET_VALUE(isolate, module, "RTLD_SELF", BigInt::New(isolate, (int64_t)RTLD_SELF));
  SET_VALUE(isolate, module, "RTLD_MAIN_ONLY", BigInt::New(isolate, (int64_t)RTLD_MAIN_ONLY));
  SET_VALUE(isolate, module, "MAP_JIT", Integer::New(isolate, (int32_t)MAP_JIT));

#endif

#ifdef __MACH__
  SET_VALUE(isolate, module, "struct_clock_t_size", Integer::New(isolate, sizeof(clock_t)));
  SET_VALUE(isolate, module, "struct_fastcall_size", Integer::New(isolate, sizeof(fastcall)));

#endif
#ifdef __linux__
  SET_VALUE(isolate, module, "struct_clock_t_size", Integer::New(isolate, sizeof(clock_t)));
  SET_VALUE(isolate, module, "struct_fastcall_size", Integer::New(isolate, sizeof(fastcall)));
  SET_VALUE(isolate, module, "struct_cpu_set_t_size", Integer::New(isolate, sizeof(cpu_set_t)));

#endif
  SET_MODULE(isolate, target, "core", module);
}
} // namespace core
} // namespace lo

extern "C"  {
  DLL_PUBLIC void* _register_core() {
    return (void*)lo::core::Init;
  }
}
