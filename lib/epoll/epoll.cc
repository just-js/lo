
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <sys/epoll.h>

#include <unistd.h>

#include <sys/prctl.h>






#include <lo.h>

namespace lo {
namespace epoll {

using v8::FunctionCallbackInfo;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Integer;
using v8::Number;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::CFunction;
using v8::CTypeInfo;
using v8::Uint8Array;
using v8::CFunctionInfo;
using v8::String;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Function;
using v8::Object;
using v8::HandleScope;
using v8::BigInt;


#ifdef __linux__

#endif
#ifdef __MACH__

#endif

int32_t createFast(void* p, int32_t p0);
CTypeInfo cargscreate[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rccreate = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infocreate = CFunctionInfo(rccreate, 2, cargscreate);
CFunction pFcreate = CFunction((const void*)&createFast, &infocreate);

int32_t modifyFast(void* p, int32_t p0, int32_t p1, int32_t p2, uint64_t* p3);
CTypeInfo cargsmodify[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcmodify = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infomodify = CFunctionInfo(rcmodify, 5, cargsmodify);
CFunction pFmodify = CFunction((const void*)&modifyFast, &infomodify);

int32_t waitFast(void* p, int32_t p0, uint64_t* p1, int32_t p2, int32_t p3);
CTypeInfo cargswait[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcwait = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowait = CFunctionInfo(rcwait, 5, cargswait);
CFunction pFwait = CFunction((const void*)&waitFast, &infowait);

int32_t pwaitFast(void* p, int32_t p0, uint64_t* p1, int32_t p2, int32_t p3, uint64_t* p4);
CTypeInfo cargspwait[6] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcpwait = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infopwait = CFunctionInfo(rcpwait, 6, cargspwait);
CFunction pFpwait = CFunction((const void*)&pwaitFast, &infopwait);

int32_t pwait2Fast(void* p, int32_t p0, uint64_t* p1, int32_t p2, uint64_t* p3, uint64_t* p4);
CTypeInfo cargspwait2[6] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcpwait2 = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infopwait2 = CFunctionInfo(rcpwait2, 6, cargspwait2);
CFunction pFpwait2 = CFunction((const void*)&pwait2Fast, &infopwait2);

int32_t closeFast(void* p, int32_t p0);
CTypeInfo cargsclose[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcclose = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoclose = CFunctionInfo(rcclose, 2, cargsclose);
CFunction pFclose = CFunction((const void*)&closeFast, &infoclose);

int32_t prctlFast(void* p, int32_t p0, uint32_t p1);
CTypeInfo cargsprctl[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcprctl = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoprctl = CFunctionInfo(rcprctl, 3, cargsprctl);
CFunction pFprctl = CFunction((const void*)&prctlFast, &infoprctl);

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

void createSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = epoll_create1(v0);
  args.GetReturnValue().Set(rc);
}

int32_t createFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return epoll_create1(v0);
}
void modifySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  struct epoll_event * v3 = reinterpret_cast<struct epoll_event *>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  int32_t rc = epoll_ctl(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t modifyFast(void* p, int32_t p0, int32_t p1, int32_t p2, uint64_t* p3) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  struct epoll_event * v3 = reinterpret_cast<struct epoll_event *>(p3);
  return epoll_ctl(v0, v1, v2, v3);
}
void waitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  struct epoll_event * v1 = reinterpret_cast<struct epoll_event *>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = epoll_wait(v0, v1, v2, v3);
  args.GetReturnValue().Set(rc);
}

int32_t waitFast(void* p, int32_t p0, uint64_t* p1, int32_t p2, int32_t p3) {
  int32_t v0 = p0;
  struct epoll_event * v1 = reinterpret_cast<struct epoll_event *>(p1);
  int32_t v2 = p2;
  int32_t v3 = p3;
  return epoll_wait(v0, v1, v2, v3);
}
void pwaitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  struct epoll_event * v1 = reinterpret_cast<struct epoll_event *>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  const sigset_t* v4 = reinterpret_cast<const sigset_t*>((uint64_t)Local<Integer>::Cast(args[4])->Value());
  int32_t rc = epoll_pwait(v0, v1, v2, v3, v4);
  args.GetReturnValue().Set(rc);
}

int32_t pwaitFast(void* p, int32_t p0, uint64_t* p1, int32_t p2, int32_t p3, uint64_t* p4) {
  int32_t v0 = p0;
  struct epoll_event * v1 = reinterpret_cast<struct epoll_event *>(p1);
  int32_t v2 = p2;
  int32_t v3 = p3;
  const sigset_t* v4 = reinterpret_cast<const sigset_t*>(p4);
  return epoll_pwait(v0, v1, v2, v3, v4);
}
void pwait2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  struct epoll_event * v1 = reinterpret_cast<struct epoll_event *>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  const struct timespec * v3 = reinterpret_cast<const struct timespec *>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  const sigset_t* v4 = reinterpret_cast<const sigset_t*>((uint64_t)Local<Integer>::Cast(args[4])->Value());
  int32_t rc = epoll_pwait2(v0, v1, v2, v3, v4);
  args.GetReturnValue().Set(rc);
}

int32_t pwait2Fast(void* p, int32_t p0, uint64_t* p1, int32_t p2, uint64_t* p3, uint64_t* p4) {
  int32_t v0 = p0;
  struct epoll_event * v1 = reinterpret_cast<struct epoll_event *>(p1);
  int32_t v2 = p2;
  const struct timespec * v3 = reinterpret_cast<const struct timespec *>(p3);
  const sigset_t* v4 = reinterpret_cast<const sigset_t*>(p4);
  return epoll_pwait2(v0, v1, v2, v3, v4);
}
void closeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = close(v0);
  args.GetReturnValue().Set(rc);
}

int32_t closeFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return close(v0);
}
void prctlSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = prctl(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t prctlFast(void* p, int32_t p0, uint32_t p1) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  return prctl(v0, v1);
}
#ifdef __linux__

#endif
#ifdef __MACH__

#endif
void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "create", &pFcreate, createSlow);
  SET_FAST_METHOD(isolate, module, "modify", &pFmodify, modifySlow);
  SET_FAST_METHOD(isolate, module, "wait", &pFwait, waitSlow);
  SET_FAST_METHOD(isolate, module, "pwait", &pFpwait, pwaitSlow);
  SET_FAST_METHOD(isolate, module, "pwait2", &pFpwait2, pwait2Slow);
  SET_FAST_METHOD(isolate, module, "close", &pFclose, closeSlow);
  SET_FAST_METHOD(isolate, module, "prctl", &pFprctl, prctlSlow);

#ifdef __linux__

#endif
#ifdef __MACH__

#endif
  SET_VALUE(isolate, module, "EPOLLIN", Integer::New(isolate, (int32_t)EPOLLIN));
  SET_VALUE(isolate, module, "EPOLLOUT", Integer::New(isolate, (int32_t)EPOLLOUT));
  SET_VALUE(isolate, module, "EPOLLERR", Integer::New(isolate, (int32_t)EPOLLERR));
  SET_VALUE(isolate, module, "EPOLLHUP", Integer::New(isolate, (int32_t)EPOLLHUP));
  SET_VALUE(isolate, module, "EPOLL_CLOEXEC", Integer::New(isolate, (int32_t)EPOLL_CLOEXEC));
  SET_VALUE(isolate, module, "EPOLLEXCLUSIVE", Integer::New(isolate, (int32_t)EPOLLEXCLUSIVE));
  SET_VALUE(isolate, module, "EPOLLWAKEUP", Integer::New(isolate, (int32_t)EPOLLWAKEUP));
  SET_VALUE(isolate, module, "EPOLLONESHOT", Integer::New(isolate, (int32_t)EPOLLONESHOT));
  SET_VALUE(isolate, module, "EPOLLET", Integer::New(isolate, (int32_t)EPOLLET));
  SET_VALUE(isolate, module, "EPOLL_CTL_ADD", Integer::New(isolate, (int32_t)EPOLL_CTL_ADD));
  SET_VALUE(isolate, module, "EPOLL_CTL_DEL", Integer::New(isolate, (int32_t)EPOLL_CTL_DEL));
  SET_VALUE(isolate, module, "EPOLL_CTL_MOD", Integer::New(isolate, (int32_t)EPOLL_CTL_MOD));
  SET_VALUE(isolate, module, "EVENT_SIZE", Number::New(isolate, (int64_t)12));
  SET_VALUE(isolate, module, "EAGAIN", Integer::New(isolate, (int32_t)EAGAIN));
  SET_VALUE(isolate, module, "PR_SET_TIMERSLACK", Integer::New(isolate, (int32_t)PR_SET_TIMERSLACK));

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

#ifdef __MACH__

#endif
#ifdef __linux__

#endif
  SET_MODULE(isolate, target, "epoll", module);
}
} // namespace epoll
} // namespace lo

extern "C"  {
  DLL_PUBLIC void* _register_epoll() {
    return (void*)lo::epoll::Init;
  }
}
