
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <io.h>

#include <direct.h>

#include <process.h>






#include <lo.h>

namespace lo {
namespace core {

using v8::FunctionCallbackInfo;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Integer;
using v8::Number;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::CFunction;
using v8::CTypeInfo;
using v8::Uint8Array;
using v8::CFunctionInfo;
using v8::String;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Function;
using v8::Object;
using v8::HandleScope;
using v8::BigInt;


#ifdef _WIN32
#define strdup _strdup
#endif


struct fastcall {
  void* wrapper;      // 0-7   :   v8 fastcall wrapper function pointer
  uint8_t result;     // 8     :   the type of the result
  uint8_t nparam;     // 9     :   the number of args (max 255) 
  uint8_t param[30];  // 10-39 :   an array of types of the arguments
  uint64_t args[32];  // 40-295:   an array of pointer slots for arguments
                      // these will be filled in dynamically by 
                      // lo::core::SlowCallback for the slow call
                      // and then the slowcall wrapper will shift them from
                      // this structure into regs + stack and make the call
                      // the first slot is reserved for the result
  void* fn;           // 296-303:  the slowcall wrapper function pointer
};

typedef void (*lo_fast_call)(void*);

inline uint8_t needsunwrap (lo::FastTypes t) {
  if (t == lo::FastTypes::buffer) return 1;
  if (t == lo::FastTypes::u32array) return 1;
  if (t == lo::FastTypes::pointer) return 1;
  if (t == lo::FastTypes::u64) return 1;
  if (t == lo::FastTypes::i64) return 1;
  return 0;
}

v8::CTypeInfo* CTypeFromV8 (uint8_t v8Type) {
  if (v8Type == lo::FastTypes::boolean)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kBool);
  if (v8Type == lo::FastTypes::i8)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::i16)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::i32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  if (v8Type == lo::FastTypes::u8)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::u16)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::u32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  if (v8Type == lo::FastTypes::f32)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat32);
  if (v8Type == lo::FastTypes::f64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat64);
  if (v8Type == lo::FastTypes::i64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt64);
  if (v8Type == lo::FastTypes::u64)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::iSize)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kInt64);
  if (v8Type == lo::FastTypes::uSize)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::pointer)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::function)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::string)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString);
  if (v8Type == lo::FastTypes::buffer)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  if (v8Type == lo::FastTypes::u32array)
    return new v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  return new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
}

void lo_fastcall (struct fastcall* state) {
  ((lo_fast_call)state->fn)(&state->args);
}

void SlowCallback(const FunctionCallbackInfo<Value> &args) {
  Isolate* isolate = args.GetIsolate();
  HandleScope scope(isolate);
  struct fastcall* state = (struct fastcall*)args.Data()
    .As<Object>()->GetAlignedPointerFromInternalField(1);
  int r = 1;
  int s = 0;
  char* temp_strs[100];
  for (int i = 0; i < state->nparam; i++) {
    switch (state->param[i]) {
      case FastTypes::string:
        {
          String::Utf8Value arg0(isolate, args[i]);
          temp_strs[s] = strdup(*arg0);
          state->args[r++] = (uint64_t)temp_strs[s++];
        }
        break;
      case FastTypes::u32:
        state->args[r++] = (uint32_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::u16:
        state->args[r++] = (uint16_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::u8:
        state->args[r++] = (uint8_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::boolean:
        state->args[r++] = (bool)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i32:
        state->args[r++] = (int32_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i16:
        state->args[r++] = (int16_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i8:
        state->args[r++] = (int8_t)Local<Integer>::Cast(args[i])->Value();
        break;
      case FastTypes::i64:
      case FastTypes::iSize:
        state->args[r++] = (int64_t)Local<Number>::Cast(args[i])->Value();
        break;
      case FastTypes::u64:
      case FastTypes::pointer:
      case FastTypes::uSize:
        state->args[r++] = (uint64_t)Local<Number>::Cast(args[i])->Value();
        break;
      case FastTypes::buffer:
        {
          Local<Uint8Array> u8 = args[i].As<Uint8Array>();
          state->args[r++] = (uint64_t)((uint8_t*)u8->Buffer()->Data() +
            u8->ByteOffset());
        }
        break;
      case FastTypes::u32array:
        {
          Local<Uint32Array> u32 = args[i].As<Uint32Array>();
          state->args[r++] = (uint64_t)((uint8_t*)u32->Buffer()->Data() +
            u32->ByteOffset());
        }
        break;
      case FastTypes::function:
        break;
      case FastTypes::f32:
        {
          float src = (float)args[i].As<v8::Number>()->Value();
          float* dst = (float*)&state->args[r++];
          *dst = src;
        }
        break;
      case FastTypes::f64:
        {
          double src = (double)args[i].As<v8::Number>()->Value();
          double* dst = (double*)&state->args[r++];
          *dst = src;
        }
        break;
    }
  }
  lo_fastcall(state);
  for (int i = 0; i < s; i++) {
    free(temp_strs[i]);
  }
  switch (state->result) {
    case FastTypes::i32:
      args.GetReturnValue().Set((int32_t)state->args[0]);
      break;
    case FastTypes::u32:
      args.GetReturnValue().Set((uint32_t)state->args[0]);
      break;
    case FastTypes::boolean:
      args.GetReturnValue().Set((bool)state->args[0]);
      break;
    case FastTypes::f32:
      {
        float* dst = (float*)&state->args[0];
        args.GetReturnValue().Set(Number::New(isolate, *dst));
      }
      break;
    case FastTypes::f64:
      {
        double* dst = (double*)&state->args[0];
        args.GetReturnValue().Set(Number::New(isolate, *dst));
      }
      break;
    case FastTypes::i64:
      {
        int64_t* res = reinterpret_cast<int64_t*>((uint64_t)Local<Integer>::Cast(args[args.Length() - 1])->Value());
        *res = state->args[0];
      }
      break;
    case FastTypes::buffer:
    case FastTypes::u32array:
    case FastTypes::u64:
    case FastTypes::pointer:
      {
        uint64_t* res = reinterpret_cast<uint64_t*>((uint64_t)Local<Integer>::Cast(args[args.Length() - 1])->Value());
        *res = state->args[0];
      }
      break;
  }
}

void bind_fastcallSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  // TODO - does integer work?
  struct fastcall* state = reinterpret_cast<struct fastcall*>(
    Local<Integer>::Cast(args[0])->Value());
  Local<ObjectTemplate> tpl = ObjectTemplate::New(isolate);
  tpl->SetInternalFieldCount(2);
  Local<Object> data = tpl->NewInstance(context).ToLocalChecked();
  data->SetAlignedPointerInInternalField(1, state);
  uint8_t unwrap = needsunwrap((FastTypes)state->result);
  int fastlen = state->nparam + 1 + unwrap;
  CTypeInfo* cargs = (CTypeInfo*)calloc(fastlen, sizeof(CTypeInfo));
  cargs[0] = CTypeInfo(CTypeInfo::Type::kV8Value);
  for (int i = 0; i < state->nparam; i++) {
    uint8_t ptype = state->param[i];
    cargs[i + 1] = *CTypeFromV8(ptype);
  }
  CTypeInfo* rc;
  if (unwrap) {
    cargs[fastlen - 1] = *CTypeFromV8(FastTypes::u32array);
    rc = CTypeFromV8(FastTypes::empty);
  } else {
    rc = CTypeFromV8((FastTypes)state->result);
  }
  CFunctionInfo* info = new CFunctionInfo(*rc, fastlen, cargs);
  CFunction* fastCFunc = new CFunction(state->wrapper, info);
  Local<FunctionTemplate> funcTemplate = FunctionTemplate::New(isolate,
    SlowCallback, data, Local<v8::Signature>(), 0, v8::ConstructorBehavior::kThrow,
    v8::SideEffectType::kHasNoSideEffect, fastCFunc
  );
  Local<Function> fun =
    funcTemplate->GetFunction(context).ToLocalChecked();
  args.GetReturnValue().Set(fun);
}

void bind_slowcallSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  struct fastcall* state = reinterpret_cast<struct fastcall*>(
    Local<Integer>::Cast(args[0])->Value());
  Local<ObjectTemplate> tpl = ObjectTemplate::New(isolate);
  tpl->SetInternalFieldCount(2);
  Local<Object> data = tpl->NewInstance(context).ToLocalChecked();
  data->SetAlignedPointerInInternalField(1, state);
  Local<FunctionTemplate> funcTemplate = FunctionTemplate::New(isolate,
    SlowCallback, data, Local<v8::Signature>(), 0, v8::ConstructorBehavior::kThrow,
    v8::SideEffectType::kHasNoSideEffect, 0
  );
  Local<Function> fun =
    funcTemplate->GetFunction(context).ToLocalChecked();
  args.GetReturnValue().Set(fun);
}

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

void callocFast(void* p, uint32_t p0, uint32_t p1, uint64_t* p_ret);
CTypeInfo cargscalloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rccalloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infocalloc = CFunctionInfo(rccalloc, 4, cargscalloc);
CFunction pFcalloc = CFunction((const void*)&callocFast, &infocalloc);

int32_t readFast(void* p, int32_t p0, uint64_t* p1, int32_t p2);
CTypeInfo cargsread[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcread = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo inforead = CFunctionInfo(rcread, 4, cargsread);
CFunction pFread = CFunction((const void*)&readFast, &inforead);

int32_t writeFast(void* p, int32_t p0, uint64_t* p1, int32_t p2);
CTypeInfo cargswrite[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcwrite = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowrite = CFunctionInfo(rcwrite, 4, cargswrite);
CFunction pFwrite = CFunction((const void*)&writeFast, &infowrite);

int32_t write_stringFast(void* p, int32_t p0, struct FastOneByteString* const p1);
CTypeInfo cargswrite_string[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcwrite_string = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infowrite_string = CFunctionInfo(rcwrite_string, 3, cargswrite_string);
CFunction pFwrite_string = CFunction((const void*)&write_stringFast, &infowrite_string);

int32_t putcharFast(void* p, int32_t p0);
CTypeInfo cargsputchar[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcputchar = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoputchar = CFunctionInfo(rcputchar, 2, cargsputchar);
CFunction pFputchar = CFunction((const void*)&putcharFast, &infoputchar);

int32_t getcharFast(void* p);
CTypeInfo cargsgetchar[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcgetchar = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetchar = CFunctionInfo(rcgetchar, 1, cargsgetchar);
CFunction pFgetchar = CFunction((const void*)&getcharFast, &infogetchar);

int32_t closeFast(void* p, int32_t p0);
CTypeInfo cargsclose[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcclose = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoclose = CFunctionInfo(rcclose, 2, cargsclose);
CFunction pFclose = CFunction((const void*)&closeFast, &infoclose);

uint32_t lseekFast(void* p, int32_t p0, uint32_t p1, int32_t p2);
CTypeInfo cargslseek[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rclseek = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infolseek = CFunctionInfo(rclseek, 4, cargslseek);
CFunction pFlseek = CFunction((const void*)&lseekFast, &infolseek);

int32_t fstatFast(void* p, int32_t p0, uint64_t* p1);
CTypeInfo cargsfstat[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcfstat = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infofstat = CFunctionInfo(rcfstat, 3, cargsfstat);
CFunction pFfstat = CFunction((const void*)&fstatFast, &infofstat);

int32_t renameFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1);
CTypeInfo cargsrename[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcrename = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo inforename = CFunctionInfo(rcrename, 3, cargsrename);
CFunction pFrename = CFunction((const void*)&renameFast, &inforename);

int32_t openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2);
CTypeInfo cargsopen[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcopen = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoopen = CFunctionInfo(rcopen, 4, cargsopen);
CFunction pFopen = CFunction((const void*)&openFast, &infoopen);

int32_t unlinkFast(void* p, struct FastOneByteString* const p0);
CTypeInfo cargsunlink[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
};
CTypeInfo rcunlink = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infounlink = CFunctionInfo(rcunlink, 2, cargsunlink);
CFunction pFunlink = CFunction((const void*)&unlinkFast, &infounlink);

void memcpyFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret);
CTypeInfo cargsmemcpy[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmemcpy = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemcpy = CFunctionInfo(rcmemcpy, 5, cargsmemcpy);
CFunction pFmemcpy = CFunction((const void*)&memcpyFast, &infomemcpy);

void memsetFast(void* p, uint64_t* p0, int32_t p1, uint32_t p2, uint64_t* p_ret);
CTypeInfo cargsmemset[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmemset = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemset = CFunctionInfo(rcmemset, 5, cargsmemset);
CFunction pFmemset = CFunction((const void*)&memsetFast, &infomemset);

void memmoveFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret);
CTypeInfo cargsmemmove[5] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmemmove = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomemmove = CFunctionInfo(rcmemmove, 5, cargsmemmove);
CFunction pFmemmove = CFunction((const void*)&memmoveFast, &infomemmove);

void mallocFast(void* p, uint32_t p0, uint64_t* p_ret);
CTypeInfo cargsmalloc[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcmalloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infomalloc = CFunctionInfo(rcmalloc, 3, cargsmalloc);
CFunction pFmalloc = CFunction((const void*)&mallocFast, &infomalloc);

void reallocFast(void* p, uint64_t* p0, uint32_t p1, uint64_t* p_ret);
CTypeInfo cargsrealloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcrealloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo inforealloc = CFunctionInfo(rcrealloc, 4, cargsrealloc);
CFunction pFrealloc = CFunction((const void*)&reallocFast, &inforealloc);

void aligned_allocFast(void* p, uint32_t p0, uint32_t p1, uint64_t* p_ret);
CTypeInfo cargsaligned_alloc[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcaligned_alloc = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoaligned_alloc = CFunctionInfo(rcaligned_alloc, 4, cargsaligned_alloc);
CFunction pFaligned_alloc = CFunction((const void*)&aligned_allocFast, &infoaligned_alloc);

void freeFast(void* p, uint64_t* p0);
CTypeInfo cargsfree[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcfree = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infofree = CFunctionInfo(rcfree, 2, cargsfree);
CFunction pFfree = CFunction((const void*)&freeFast, &infofree);

void fastcallFast(void* p, uint64_t* p0);
CTypeInfo cargsfastcall[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcfastcall = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infofastcall = CFunctionInfo(rcfastcall, 2, cargsfastcall);
CFunction pFfastcall = CFunction((const void*)&fastcallFast, &infofastcall);

void getenvFast(void* p, struct FastOneByteString* const p0, uint64_t* p_ret);
CTypeInfo cargsgetenv[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcgetenv = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infogetenv = CFunctionInfo(rcgetenv, 3, cargsgetenv);
CFunction pFgetenv = CFunction((const void*)&getenvFast, &infogetenv);

int32_t dupFast(void* p, int32_t p0);
CTypeInfo cargsdup[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcdup = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infodup = CFunctionInfo(rcdup, 2, cargsdup);
CFunction pFdup = CFunction((const void*)&dupFast, &infodup);

int32_t dup2Fast(void* p, int32_t p0, int32_t p1);
CTypeInfo cargsdup2[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcdup2 = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infodup2 = CFunctionInfo(rcdup2, 3, cargsdup2);
CFunction pFdup2 = CFunction((const void*)&dup2Fast, &infodup2);

void getcwdFast(void* p, uint64_t* p0, int32_t p1, uint64_t* p_ret);
CTypeInfo cargsgetcwd[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kInt32),
  CTypeInfo(CTypeInfo::Type::kUint64)
};
CTypeInfo rcgetcwd = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infogetcwd = CFunctionInfo(rcgetcwd, 4, cargsgetcwd);
CFunction pFgetcwd = CFunction((const void*)&getcwdFast, &infogetcwd);

int32_t getpidFast(void* p);
CTypeInfo cargsgetpid[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcgetpid = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infogetpid = CFunctionInfo(rcgetpid, 1, cargsgetpid);
CFunction pFgetpid = CFunction((const void*)&getpidFast, &infogetpid);

int32_t execveFast(void* p, struct FastOneByteString* const p0, uint64_t* p1, uint64_t* p2);
CTypeInfo cargsexecve[4] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcexecve = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoexecve = CFunctionInfo(rcexecve, 4, cargsexecve);
CFunction pFexecve = CFunction((const void*)&execveFast, &infoexecve);

int32_t execvpFast(void* p, struct FastOneByteString* const p0, uint64_t* p1);
CTypeInfo cargsexecvp[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kSeqOneByteString),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcexecvp = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoexecvp = CFunctionInfo(rcexecvp, 3, cargsexecvp);
CFunction pFexecvp = CFunction((const void*)&execvpFast, &infoexecvp);

void exitFast(void* p, int32_t p0);
CTypeInfo cargsexit[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcexit = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoexit = CFunctionInfo(rcexit, 2, cargsexit);
CFunction pFexit = CFunction((const void*)&exitFast, &infoexit);

void isolate_context_destroyFast(void* p, uint64_t* p0);
CTypeInfo cargsisolate_context_destroy[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
};
CTypeInfo rcisolate_context_destroy = CTypeInfo(CTypeInfo::Type::kVoid);
CFunctionInfo infoisolate_context_destroy = CFunctionInfo(rcisolate_context_destroy, 2, cargsisolate_context_destroy);
CFunction pFisolate_context_destroy = CFunction((const void*)&isolate_context_destroyFast, &infoisolate_context_destroy);

int32_t isolate_context_sizeFast(void* p);
CTypeInfo cargsisolate_context_size[1] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),

};
CTypeInfo rcisolate_context_size = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoisolate_context_size = CFunctionInfo(rcisolate_context_size, 1, cargsisolate_context_size);
CFunction pFisolate_context_size = CFunction((const void*)&isolate_context_sizeFast, &infoisolate_context_size);

uint32_t strnlenFast(void* p, uint64_t* p0, uint32_t p1);
CTypeInfo cargsstrnlen[3] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kUint64),
  CTypeInfo(CTypeInfo::Type::kUint32),
};
CTypeInfo rcstrnlen = CTypeInfo(CTypeInfo::Type::kUint32);
CFunctionInfo infostrnlen = CFunctionInfo(rcstrnlen, 3, cargsstrnlen);
CFunction pFstrnlen = CFunction((const void*)&strnlenFast, &infostrnlen);

int32_t isattyFast(void* p, int32_t p0);
CTypeInfo cargsisatty[2] = {
  CTypeInfo(CTypeInfo::Type::kV8Value),
  CTypeInfo(CTypeInfo::Type::kInt32),
};
CTypeInfo rcisatty = CTypeInfo(CTypeInfo::Type::kInt32);
CFunctionInfo infoisatty = CFunctionInfo(rcisatty, 2, cargsisatty);
CFunction pFisatty = CFunction((const void*)&isattyFast, &infoisatty);

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

void callocSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = calloc(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void callocFast(void* p, uint32_t p0, uint32_t p1, uint64_t* p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = calloc(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void readSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = _read(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t readFast(void* p, int32_t p0, uint64_t* p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1);
  int32_t v2 = p2;
  return _read(v0, v1, v2);
}
void writeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = _write(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t writeFast(void* p, int32_t p0, uint64_t* p1, int32_t p2) {
  int32_t v0 = p0;
  void* v1 = reinterpret_cast<void*>(p1);
  int32_t v2 = p2;
  return _write(v0, v1, v2);
}
void write_stringSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  String::Utf8Value v1(isolate, args[1]);
  int32_t v2 = v1.length();
  int32_t rc = _write(v0, *v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t write_stringFast(void* p, int32_t p0, struct FastOneByteString* const p1) {
  int32_t v0 = p0;
  struct FastOneByteString* const v1 = p1;
  int32_t v2 = p1->length;
  return _write(v0, v1->data, v2);
}
void putcharSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = putchar(v0);
  args.GetReturnValue().Set(rc);
}

int32_t putcharFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return putchar(v0);
}
void getcharSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = getchar();
  args.GetReturnValue().Set(rc);
}

int32_t getcharFast(void* p) {

  return getchar();
}
void closeSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = _close(v0);
  args.GetReturnValue().Set(rc);
}

int32_t closeFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return _close(v0);
}
void lseekSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  uint32_t rc = _lseek(v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

uint32_t lseekFast(void* p, int32_t p0, uint32_t p1, int32_t p2) {
  int32_t v0 = p0;
  uint32_t v1 = p1;
  int32_t v2 = p2;
  return _lseek(v0, v1, v2);
}
void fstatSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  struct _stat * v1 = reinterpret_cast<struct _stat *>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = _fstat(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t fstatFast(void* p, int32_t p0, uint64_t* p1) {
  int32_t v0 = p0;
  struct _stat * v1 = reinterpret_cast<struct _stat *>(p1);
  return _fstat(v0, v1);
}
void renameSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  String::Utf8Value v1(isolate, args[1]);
  int32_t rc = rename(*v0, *v1);
  args.GetReturnValue().Set(rc);
}

int32_t renameFast(void* p, struct FastOneByteString* const p0, struct FastOneByteString* const p1) {
  struct FastOneByteString* const v0 = p0;
  struct FastOneByteString* const v1 = p1;
  return rename(v0->data, v1->data);
}
void openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t rc = _open(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t openFast(void* p, struct FastOneByteString* const p0, int32_t p1, int32_t p2) {
  struct FastOneByteString* const v0 = p0;
  int32_t v1 = p1;
  int32_t v2 = p2;
  return _open(v0->data, v1, v2);
}
void unlinkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = _unlink(*v0);
  args.GetReturnValue().Set(rc);
}

int32_t unlinkFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return _unlink(v0->data);
}
void memcpySlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memcpy(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void memcpyFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memcpy(v0, v1, v2);

  p_ret[0] = (uint64_t)r;
}
void memsetSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memset(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void memsetFast(void* p, uint64_t* p0, int32_t p1, uint32_t p2, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  int32_t v1 = p1;
  uint32_t v2 = p2;
  void* r = memset(v0, v1, v2);

  p_ret[0] = (uint64_t)r;
}
void memmoveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  void* rc = memmove(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void memmoveFast(void* p, uint64_t* p0, uint64_t* p1, uint32_t p2, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  void* v1 = reinterpret_cast<void*>(p1);
  uint32_t v2 = p2;
  void* r = memmove(v0, v1, v2);

  p_ret[0] = (uint64_t)r;
}
void mallocSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  void* rc = malloc(v0);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void mallocFast(void* p, uint32_t p0, uint64_t* p_ret) {
  uint32_t v0 = p0;
  void* r = malloc(v0);

  p_ret[0] = (uint64_t)r;
}
void reallocSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = realloc(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void reallocFast(void* p, uint64_t* p0, uint32_t p1, uint64_t* p_ret) {
  void* v0 = reinterpret_cast<void*>(p0);
  uint32_t v1 = p1;
  void* r = realloc(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void aligned_allocSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = _aligned_malloc(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void aligned_allocFast(void* p, uint32_t p0, uint32_t p1, uint64_t* p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  void* r = _aligned_malloc(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  free(v0);
}

void freeFast(void* p, uint64_t* p0) {
  void* v0 = reinterpret_cast<void*>(p0);
  free(v0);
}
void fastcallSlow(const FunctionCallbackInfo<Value> &args) {
  struct fastcall* v0 = reinterpret_cast<struct fastcall*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_fastcall(v0);
}

void fastcallFast(void* p, uint64_t* p0) {
  struct fastcall* v0 = reinterpret_cast<struct fastcall*>(p0);
  lo_fastcall(v0);
}
void getenvSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* rc = getenv(*v0);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void getenvFast(void* p, struct FastOneByteString* const p0, uint64_t* p_ret) {
  struct FastOneByteString* const v0 = p0;
  char* r = getenv(v0->data);

  p_ret[0] = (uint64_t)r;
}
void dupSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = _dup(v0);
  args.GetReturnValue().Set(rc);
}

int32_t dupFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return _dup(v0);
}
void dup2Slow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = _dup2(v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t dup2Fast(void* p, int32_t p0, int32_t p1) {
  int32_t v0 = p0;
  int32_t v1 = p1;
  return _dup2(v0, v1);
}
void getcwdSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  void* rc = _getcwd(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, reinterpret_cast<uint64_t>(rc)));
}

void getcwdFast(void* p, uint64_t* p0, int32_t p1, uint64_t* p_ret) {
  char* v0 = reinterpret_cast<char*>(p0);
  int32_t v1 = p1;
  void* r = _getcwd(v0, v1);

  p_ret[0] = (uint64_t)r;
}
void getpidSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = _getpid();
  args.GetReturnValue().Set(rc);
}

int32_t getpidFast(void* p) {

  return _getpid();
}
void execveSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* const* v1 = reinterpret_cast<char* const*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  char* const* v2 = reinterpret_cast<char* const*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = _execve(*v0, v1, v2);
  args.GetReturnValue().Set(rc);
}

int32_t execveFast(void* p, struct FastOneByteString* const p0, uint64_t* p1, uint64_t* p2) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1);
  char* const* v2 = reinterpret_cast<char* const*>(p2);
  return _execve(v0->data, v1, v2);
}
void execvpSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  char* const* v1 = reinterpret_cast<char* const*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = _execvp(*v0, v1);
  args.GetReturnValue().Set(rc);
}

int32_t execvpFast(void* p, struct FastOneByteString* const p0, uint64_t* p1) {
  struct FastOneByteString* const v0 = p0;
  char* const* v1 = reinterpret_cast<char* const*>(p1);
  return _execvp(v0->data, v1);
}
void exitSlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  exit(v0);
}

void exitFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  exit(v0);
}
void isolate_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  char** v1 = reinterpret_cast<char**>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  String::Utf8Value v2(isolate, args[2]);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  String::Utf8Value v4(isolate, args[4]);
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  char* v6 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[6])->Value());
  int32_t v7 = Local<Integer>::Cast(args[7])->Value();
  int32_t v8 = Local<Integer>::Cast(args[8])->Value();
  uint64_t v9 = Local<Integer>::Cast(args[9])->Value();
  String::Utf8Value v10(isolate, args[10]);
  String::Utf8Value v11(isolate, args[11]);
  int32_t v12 = Local<Integer>::Cast(args[12])->Value();
  int32_t v13 = Local<Integer>::Cast(args[13])->Value();
  void* v14 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[14])->Value());
  int32_t rc = lo_create_isolate(v0, v1, *v2, v3, *v4, v5, v6, v7, v8, v9, *v10, *v11, v12, v13, v14);
  args.GetReturnValue().Set(rc);
}

void isolate_context_createSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  char** v1 = reinterpret_cast<char**>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  String::Utf8Value v2(isolate, args[2]);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  String::Utf8Value v4(isolate, args[4]);
  uint32_t v5 = Local<Integer>::Cast(args[5])->Value();
  char* v6 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[6])->Value());
  int32_t v7 = Local<Integer>::Cast(args[7])->Value();
  int32_t v8 = Local<Integer>::Cast(args[8])->Value();
  uint64_t v9 = Local<Integer>::Cast(args[9])->Value();
  String::Utf8Value v10(isolate, args[10]);
  String::Utf8Value v11(isolate, args[11]);
  int32_t v12 = Local<Integer>::Cast(args[12])->Value();
  int32_t v13 = Local<Integer>::Cast(args[13])->Value();
  void* v14 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[14])->Value());
  struct isolate_context* v15 = reinterpret_cast<struct isolate_context*>((uint64_t)Local<Integer>::Cast(args[15])->Value());
  lo_create_isolate_context(v0, v1, *v2, v3, *v4, v5, v6, v7, v8, v9, *v10, *v11, v12, v13, v14, v15);
}

void isolate_context_destroySlow(const FunctionCallbackInfo<Value> &args) {
  struct isolate_context* v0 = reinterpret_cast<struct isolate_context*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_destroy_isolate_context(v0);
}

void isolate_context_destroyFast(void* p, uint64_t* p0) {
  struct isolate_context* v0 = reinterpret_cast<struct isolate_context*>(p0);
  lo_destroy_isolate_context(v0);
}
void isolate_context_sizeSlow(const FunctionCallbackInfo<Value> &args) {

  int32_t rc = lo_context_size();
  args.GetReturnValue().Set(rc);
}

int32_t isolate_context_sizeFast(void* p) {

  return lo_context_size();
}
void isolate_startSlow(const FunctionCallbackInfo<Value> &args) {
  void* v0 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_start_isolate(v0);
}

void callbackSlow(const FunctionCallbackInfo<Value> &args) {
  exec_info* v0 = reinterpret_cast<exec_info*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  lo_callback(v0);
}

void strnlenSlow(const FunctionCallbackInfo<Value> &args) {
  const char* v0 = reinterpret_cast<const char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  uint32_t rc = strnlen(v0, v1);
  args.GetReturnValue().Set(rc);
}

uint32_t strnlenFast(void* p, uint64_t* p0, uint32_t p1) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  uint32_t v1 = p1;
  return strnlen(v0, v1);
}
void isattySlow(const FunctionCallbackInfo<Value> &args) {
  int32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t rc = _isatty(v0);
  args.GetReturnValue().Set(rc);
}

int32_t isattyFast(void* p, int32_t p0) {
  int32_t v0 = p0;
  return _isatty(v0);
}
#ifdef __linux__

#endif
#ifdef __MACH__

#endif
void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "calloc", &pFcalloc, callocSlow);
  SET_FAST_METHOD(isolate, module, "read", &pFread, readSlow);
  SET_FAST_METHOD(isolate, module, "write", &pFwrite, writeSlow);
  SET_FAST_METHOD(isolate, module, "write_string", &pFwrite_string, write_stringSlow);
  SET_FAST_METHOD(isolate, module, "putchar", &pFputchar, putcharSlow);
  SET_FAST_METHOD(isolate, module, "getchar", &pFgetchar, getcharSlow);
  SET_FAST_METHOD(isolate, module, "close", &pFclose, closeSlow);
  SET_FAST_METHOD(isolate, module, "lseek", &pFlseek, lseekSlow);
  SET_FAST_METHOD(isolate, module, "fstat", &pFfstat, fstatSlow);
  SET_FAST_METHOD(isolate, module, "rename", &pFrename, renameSlow);
  SET_FAST_METHOD(isolate, module, "open", &pFopen, openSlow);
  SET_FAST_METHOD(isolate, module, "unlink", &pFunlink, unlinkSlow);
  SET_FAST_METHOD(isolate, module, "memcpy", &pFmemcpy, memcpySlow);
  SET_FAST_METHOD(isolate, module, "memset", &pFmemset, memsetSlow);
  SET_FAST_METHOD(isolate, module, "memmove", &pFmemmove, memmoveSlow);
  SET_FAST_METHOD(isolate, module, "malloc", &pFmalloc, mallocSlow);
  SET_FAST_METHOD(isolate, module, "realloc", &pFrealloc, reallocSlow);
  SET_FAST_METHOD(isolate, module, "aligned_alloc", &pFaligned_alloc, aligned_allocSlow);
  SET_FAST_METHOD(isolate, module, "free", &pFfree, freeSlow);
  SET_METHOD(isolate, module, "bind_fastcall", bind_fastcallSlow);
  SET_METHOD(isolate, module, "bind_slowcall", bind_slowcallSlow);
  SET_FAST_METHOD(isolate, module, "fastcall", &pFfastcall, fastcallSlow);
  SET_FAST_METHOD(isolate, module, "getenv", &pFgetenv, getenvSlow);
  SET_FAST_METHOD(isolate, module, "dup", &pFdup, dupSlow);
  SET_FAST_METHOD(isolate, module, "dup2", &pFdup2, dup2Slow);
  SET_FAST_METHOD(isolate, module, "getcwd", &pFgetcwd, getcwdSlow);
  SET_FAST_METHOD(isolate, module, "getpid", &pFgetpid, getpidSlow);
  SET_FAST_METHOD(isolate, module, "execve", &pFexecve, execveSlow);
  SET_FAST_METHOD(isolate, module, "execvp", &pFexecvp, execvpSlow);
  SET_FAST_METHOD(isolate, module, "exit", &pFexit, exitSlow);
  SET_METHOD(isolate, module, "isolate_create", isolate_createSlow);
  SET_METHOD(isolate, module, "isolate_context_create", isolate_context_createSlow);
  SET_FAST_METHOD(isolate, module, "isolate_context_destroy", &pFisolate_context_destroy, isolate_context_destroySlow);
  SET_FAST_METHOD(isolate, module, "isolate_context_size", &pFisolate_context_size, isolate_context_sizeSlow);
  SET_METHOD(isolate, module, "isolate_start", isolate_startSlow);
  SET_METHOD(isolate, module, "callback", callbackSlow);
  SET_FAST_METHOD(isolate, module, "strnlen", &pFstrnlen, strnlenSlow);
  SET_FAST_METHOD(isolate, module, "isatty", &pFisatty, isattySlow);

#ifdef __linux__

#endif
#ifdef __MACH__

#endif
  SET_VALUE(isolate, module, "S_IFCHR", Integer::New(isolate, (int32_t)S_IFCHR));
  SET_VALUE(isolate, module, "O_RDONLY", Integer::New(isolate, (int32_t)O_RDONLY));
  SET_VALUE(isolate, module, "O_WRONLY", Integer::New(isolate, (int32_t)O_WRONLY));
  SET_VALUE(isolate, module, "O_CREAT", Integer::New(isolate, (int32_t)O_CREAT));
  SET_VALUE(isolate, module, "O_TRUNC", Integer::New(isolate, (int32_t)O_TRUNC));
  SET_VALUE(isolate, module, "STDIN", Number::New(isolate, (int64_t)0));
  SET_VALUE(isolate, module, "STDOUT", Number::New(isolate, (int64_t)1));
  SET_VALUE(isolate, module, "STDERR", Number::New(isolate, (int64_t)2));
  SET_VALUE(isolate, module, "SEEK_SET", Integer::New(isolate, (int32_t)SEEK_SET));
  SET_VALUE(isolate, module, "SEEK_CUR", Integer::New(isolate, (int32_t)SEEK_CUR));
  SET_VALUE(isolate, module, "SEEK_END", Integer::New(isolate, (int32_t)SEEK_END));
  SET_VALUE(isolate, module, "S_IFMT", Integer::New(isolate, (int32_t)S_IFMT));
  SET_VALUE(isolate, module, "S_IFDIR", Integer::New(isolate, (int32_t)S_IFDIR));
  SET_VALUE(isolate, module, "S_IFREG", Integer::New(isolate, (int32_t)S_IFREG));
  SET_VALUE(isolate, module, "O_RDWR", Integer::New(isolate, (int32_t)O_RDWR));
  SET_VALUE(isolate, module, "EAGAIN", Integer::New(isolate, (int32_t)EAGAIN));
  SET_VALUE(isolate, module, "_S_IREAD", Integer::New(isolate, (int32_t)_S_IREAD));
  SET_VALUE(isolate, module, "_S_IWRITE", Integer::New(isolate, (int32_t)_S_IWRITE));
  SET_VALUE(isolate, module, "_O_APPEND", Integer::New(isolate, (int32_t)_O_APPEND));
  SET_VALUE(isolate, module, "_O_BINARY", Integer::New(isolate, (int32_t)_O_BINARY));
  SET_VALUE(isolate, module, "_O_CREAT", Integer::New(isolate, (int32_t)_O_CREAT));
  SET_VALUE(isolate, module, "_O_RDONLY", Integer::New(isolate, (int32_t)_O_RDONLY));
  SET_VALUE(isolate, module, "_O_RDWR", Integer::New(isolate, (int32_t)_O_RDWR));
  SET_VALUE(isolate, module, "_O_TEXT", Integer::New(isolate, (int32_t)_O_TEXT));
  SET_VALUE(isolate, module, "_O_TRUNC", Integer::New(isolate, (int32_t)_O_TRUNC));
  SET_VALUE(isolate, module, "_O_WRONLY", Integer::New(isolate, (int32_t)_O_WRONLY));
  SET_VALUE(isolate, module, "_O_U16TEXT", Integer::New(isolate, (int32_t)_O_U16TEXT));
  SET_VALUE(isolate, module, "_O_U8TEXT", Integer::New(isolate, (int32_t)_O_U8TEXT));

#ifdef __linux__

#endif
#ifdef __MACH__

#endif

#ifdef __MACH__
  SET_VALUE(isolate, module, "struct_fastcall_size", Integer::New(isolate, sizeof(fastcall)));

#endif
#ifdef __linux__
  SET_VALUE(isolate, module, "struct_fastcall_size", Integer::New(isolate, sizeof(fastcall)));

#endif
  SET_MODULE(isolate, target, "core", module);
}
} // namespace core
} // namespace lo

extern "C"  {
  DLL_PUBLIC void* _register_core() {
    return (void*)lo::core::Init;
  }
}
